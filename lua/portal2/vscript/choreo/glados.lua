--ispaused()
--IsPlayingBack()
--EstimateLength()

-- DBG stuff
local DBG = true       -- Set true to enable DBG block during think function
local DBGInterval = 10.00

local lastthink = CurTime()
local startBlock = 0

-- Queue of scenes started with GladosPlayVcd()
local scenequeue = {}
local firedfromqueue = false

-- Map Name
local curMapName = game.GetMap()

-- PitchShifting stuff
local pitchShifting = false
local pitchShiftLastThink = CurTime()
local pitchShiftInterval = 1.0
local pitchShiftValue = 1.0
local pitchOverride = nil

-- State Flags
local stateSlowFieldTraining = false

-- jailbreak specific stuff
if curMapName == "sp_sabotage_jailbreak_01" or curMapName == "sp_sabotage_jailbreak" or curMapName == "sp_a2_bts1" then
    jailbreakpos = 0
end

-- sp_catapult_fling_sphere_peek specific stuff
if curMapName == "sp_a2_sphere_peek" then
    peekctr = 0
end


--Dings
local sceneDingOn  = CreateSceneEntity("scenes/npc/glados_manual/ding_on.vcd")
local sceneDingOff = CreateSceneEntity("scenes/npc/glados_manual/ding_off.vcd")

--Include the autogenerated scene table
include("portal2/vscript/choreo/glados_scenetable_include.lua")

--Include the manual scene table
include("portal2/vscript/choreo/glados_scenetable_include_manual.lua")

function printlDBG(arg)
	if DBG then
		print(arg)
	end
end


-- -------------------------------------------------------------------
-- Precache sounds we will emit
-- Define like this: self.PrecacheSoundScript( "Your.SoundName" )
--
-- Then you call the sound like so:
-- self.EmitSound("Your.SoundName")
-- -------------------------------------------------------------------
function Precache()          
	if curMapName=="sp_a4_tb_trust_drop" then
		self.PrecacheSoundScript( "World.WheatleyZap" )
	end
	if curMapName=="sp_a1_wakeup" then
		self.PrecacheSoundScript( "World.HackBuzzer" )
	end
	if curMapName=="sp_a3_speed_ramp" then
		self.PrecacheSoundScript( "World.WheatleyZap" )
		self.PrecacheSoundScript( "World.GladosPotatoZap" )
	end
	if curMapName=="sp_a3_transition01" then
		self.PrecacheSoundScript( "World.GladosPotatoZap" )
end

end

--function testemito()
--{
--	self.EmitSound("World.Electrocution")
--}




-- OnPostSpawn - this is all the initial setup stuff
function OnPostSpawn()
		local i = 0
		--assign a unique id to each scene entity (uses SetTeam because that's the only thing available)
		for _, val in ipairs(SceneTable) do
			i = i + 1
			val.vcd:ValidateScriptScope()
			val.vcd:SetTeam(i)
			val.index = i
		end	
		--Initialize the deferred scene queue
		QueueInitialize()
		PuzzlePreStart()
		
		--Map specific Spawn stuff
		if curMapName == "sp_a1_wakeup" then
   			EntFire("@glados", "runscriptcode", "sp_a1_wakeup_start_map()", 1.0)
		end
end



--Passed the unique team id associated with a scene entity defined in SceneTable, this function returns the correct SceneTable index for that entry
--ex: SceneTableInst = SceneTable[findIndex(team)]
function findIndex(team)
		local idx, val
		for idx, val in ipairs(SceneTable) do
			if val.index == team then
				return idx
			end
		end
		return nil
end

--Passed the unique team id associated with a scene entity defined in SceneTable, this function returns the scene instance that originally fired it.
--Unfortunately, if multiple scene instances fire the same vcd, this isn't reliable. Hopefully we can either a) fix that 
--or b) not have multiple scene instances use the same vcd (which is currently the case as of 07/19/2010 - efw)
function FindSceneInstanceByTeam(team)
	local idx, val
	local idx2, val2
	local inst = nil
	for idx, val in ipairs(scenequeue) do
		for idx2, val2 in ipairs(val.waitFiredVcds) do
			if val2 == team then
				inst = val
				break
			end
		end
		if inst ~= nil then
			break
		end
	end
	return inst
end


function SceneCanceled()
	printlDBG("========SCENE CANCELLED - CALLING ENTITY: "+findIndex(owninginstance.GetTeam()))
end

--If a vcd is tagged to "exit early" (by setting postdelay < 0), this event fires rather than PlayNextScene() when the vcd finishes.
--SkipOnCompletion() has all the functionality of PlayNextScene(), except it doesn't actually play the next scene, because the next scene presumably
--already started playing when the vcd exited early.
--SkipOnCompletion does, however, evaluate the vcd's SceneTable entry to see if any EntFires need to happen.
function SkipOnCompletion()
    printlDBG("========SKIPONCOMPLETION CALLING ENTITY: " .. findIndex(owninginstance:GetTeam()) .. " : TIME " .. CurTime())

    local team = owninginstance:GetTeam()
    local inst = FindSceneInstanceByTeam(team)

    if inst ~= nil then
        inst:deleteFiredVcd(team)
        inst.waitVcdCurrent = findIndex(team)

        -- Are there any EntFires associated with this vcd?
        if inst.waitVcdCurrent ~= nil and SceneTable[inst.waitVcdCurrent].fires then
            for _, val in ipairs(SceneTable[inst.waitVcdCurrent].fires) do
                if not val.fireatstart then
                    printlDBG(">>>>>>ENT FIRE AT (SKIPCOMPLETION) END: " .. val.entity .. ":" .. val.input)
                    EntFire(val.entity, val.input, val.parameter, val.delay)
                end
            end
        end
    end
end


function PlayNextScene()
    local team = owninginstance:GetTeam()
    local inst = FindSceneInstanceByTeam(team)

    if inst ~= nil then
        printlDBG("========PLAYNEXTSCENE CALLING ENTITY: " .. findIndex(owninginstance:GetTeam()) .. " : TIME " .. CurTime())
        inst:deleteFiredVcd(team)
        inst.waitVcdCurrent = findIndex(team)
        PlayNextSceneInternal(inst)
    else
        printlDBG("========PLAYNEXTSCENE CALLING ENTITY NO LONGER EXISTS: CHECKING QUEUE...")
        QueueCheck()
    end
end



function PlayNextSceneInternal(inst)
    -- inst = just completed scene
    local i = 0
    local tmp = 0


    -- Are there any "fire at the end" triggers associated with the just completed?
    if inst and inst.waitVcdCurrent ~= nil then
        if SceneTable[inst.waitVcdCurrent].fires then
            for idx, val in ipairs(SceneTable[inst.waitVcdCurrent].fires) do
                if not val.fireatstart then
                    printlDBG(">>>>>>ENT FIRE AT END: " .. val.entity .. ":" .. val.input)
                    EntFire(val.entity, val.input, val.parameter, val.delay)
                end
            end
        end
    end

    -- If the vcd that's ending is part of a nag cycle, check to see if there are queued scenes.
    if inst and inst.isNag then
        if QueueLen(inst.currentCharacter) > 0 then
            printlDBG("========ABANDONING NAG CYCLE TO PLAY QUEUED SCENE")
            scenequeue_DeleteScene(inst.index)
            QueueCheck()
            return
        end
    end

    -- Is there another vcd in the scene chain?
    if inst and inst.waitNext ~= nil then
        printlDBG("=====There is a next scene: " .. tostring(inst.waitNext))
        local nextScene = inst.waitNext        -- save before we kill the slot
        scenequeue_DeleteScene(inst.index)     -- free the finished scene
        GladosPlayVcd(nextScene)               -- start the new one
        return                                   -- nothing more to do
    else
        printlDBG("=====No next scene!")
        -- Remove the instance from the scene list
        scenequeue_DeleteScene(inst.index)
        -- Check for queued scenes
        if QueueCheck() then return end
        -- Ding if nothing is queued and the previous scene requires it
        if not inst.waitNoDingOff then
            EntFire(sceneDingOff, "Start", "", 0.1, nil, nil)
        end
    end
end


--Think function
function GladosThink()
	--Put DBG stuff here!
	if DBG then
		if CurTime() - lastthink > DBGInterval then
			printlDBG("===================GladosThink-> " .. lastthink)
			lastthink = CurTime()
			QueueDBG()
        end
	end
	--Is GLaDOS gibbering
	--if (glados_gibbering)
	--{
		--sp_sabotage_glados_gibberish()
	--}
	--Are we PitchShifting?
	if pitchShifting then
		if CurTime() - pitchShiftLastThink > pitchShiftInterval then
			local curscene = self:GetCurrentScene()
			if curscene ~= nil then
				local shiftAmount = math.Rand( -0.10, 0.10)
				if shiftAmount < 0.00 then
					shiftAmount = shiftAmount * 1.5
                end
				pitchShiftValue = pitchShiftValue + shiftAmount
				if pitchShiftValue <= 0.0 or pitchShiftValue >= 1.7 then
					pitchShiftValue = pitchShiftValue - ShiftAmount * 2
                end
				EntFire( curscene, "PitchShift", tostring(pitchShiftValue), 0, nil, nil )
				pitchShiftInterval = math.Rand( 0.1, 0.2)
            end
			--Set Lastthink
			pitchShiftLastThink = CurTime()
		end
	end
	
	
	local idx, val
	--scan the list of currently playing scenes.
	for idx,val in ipairs(scenequeue) do
		--Check if the current vcd is scheduled to exit early
		if val.waitPreDelayed then
			if CurTime() >= val.waitDelayingUntil then
				printlDBG("*******LAUNCHING PREDELAYED SCENE")
				GladosPlayVcd(val)
            end
        end
		if val.waitExitingEarly then
			if CurTime() - val.waitExitingEarlyStartTime >= val.waitExitingEarlyThreshold then
				local team
				val.waitExitingEarly=false
				local curscene = characterCurscene(val.currentCharacter)
				if curscene ~= nil then
					curscene.ValidateScriptScope()
					curscene.GetScriptScope().SkipOnCompletion = SkipOnCompletion.bindenv(this)
					curscene.DisconnectOutput("OnCompletion", "PlayNextScene")
					curscene.DisconnectOutput("OnCompletion", "SkipOnCompletion")
					curscene.ConnectOutput( "OnCompletion", "SkipOnCompletion" )
					team = curscene.GetTeam()
					val.waitVcdCurrent = findIndex(team)
                end
				printlDBG("====Scene "..val.index.." EXITING EARLY")
				PlayNextSceneInternal(val)
				return
			end
		end
	end
	
	local tmp
	--Check the deferred scene queue
	tmp = QueueThink()
	--Is a queued scene ready to fire?
	if tmp ~= nil then
			printlDBG("===========FORCING QUEUED SCENE: "..tmp)
			GladosPlayVcd(tmp,true)
			return
    end

	for idx,val in ipairs(scenequeue) do
		--Are we waiting to play another vcd?
		if val.waiting == 1 then
			if CurTime() - val.waitStartTime >= val.waitLength then
				val.waiting = 0
				GladosPlayVcd(val)
            end
		end
	end
end

concommand.Add("gladosplayvcd", function(ply, cmd, args, argStr)
    if ply:IsAdmin() then
        local param = args[1]
        GladosPlayVcd(tonumber(param))
    else
        print("You need permission to run this command")
    end
end, nil, "Runs GladosPlayVcd with the provided scene number.")
--[[
hook.Add("Think", "SceneQueue_PreDelayPoller", function()
    for name, inst in ipairs(scenequeue) do
        if inst.waitPreDelayed and CurTime() >= inst.waitDelayingUntil then
            inst.waitPreDelayed = false
            GladosPlayVcd(inst)       -- delay expired, continue scene
        end
    end
end)
]]
--Play a vcd from the SceneTable, plus set up next line (if any).
--This is the function that should be used to start a scene from inside a map.
function GladosPlayVcd(arg, IgnoreQueue, caller)
--arg==instance	-> Continue playing scene defined by scene class instance arg
--arg==integer	-> Start playing new scene (scene being a chain of vcds) from SceneTable[SceneTableLookup[arg]]
--arg==string		-> Start playing new scene (scene being a chain of vcds) from SceneTable[arg]
--arg==nil			-> Continue playing current scene with next vcd in current chain
--IgnoreQueue		-> true == don't check for queue status (this is used to force a queued vcd to play)
--caller				-> If passed as an entity, the vcd will have its "target1" set to caller.GetName()
	printlDBG("=========GladosPlayVcd Called!========="..arg)
    IgnoreQueue = IgnoreQueue or nil
    caller = caller or nil
	local dingon = false
	
	local inst
	local fromqueue = firedfromqueue
	firedfromqueue = false
	
	if type(arg) == "table" then
		--if this is a vcd that was being held for predelay, play it
		if arg.waitPreDelayed then
			inst = arg
			arg = inst.waitPreDelayedEntry
		--otherwise, play the next vcd in the chain
		else
			inst = arg
			arg=inst.waitNext
        end
	else
		--If this is a call from the map, look up the integer arg in the scene lookup table.
		--We need to do this because hammer/the engine can't pass a squirrel script a string, just an integer.
		--In other words, from a map, @glados.GladosPlayVcd("MyVcd") crashes the game. GladosPlayVcd(16) doesn't.
		local sceneStart = 0
		if type(arg) == "number" then
			if arg == 407 or arg == 43 then --remove this line without changing map (12/21/2010)
				return
            end
			sceneStart = arg
			printlDBG("{}{}{}{}{}{}{}{}{}GladosPlayVcd: "..arg)	
			arg = SceneTableLookup[arg]
		else
			sceneStart = 0
        end
		--if SkipIfBusy is present & we're already playing a scene, skip this new scene
		if SceneTable.skipifbusy then
			if characterCurscene(SceneTable[arg].char) ~= nil then
				return
            end
		end
		--if queue is present & we're already playing a scene, add scene to queue
		if not SceneTable[arg] then
			print("GladosPlayVcd: ERROR - SceneTable entry "..tostring(arg).." does not exist (or is not converted)!")
			return;
		end
 		if SceneTable[arg].queue then
	 		if IgnoreQueue == nil then
				--queue if a specific character is talking 
		 		if SceneTable[arg].queuecharacter then
					if characterCurscene(SceneTable[arg].queuecharacter) ~= nil then
				 		QueueAdd(arg)
			 			return
                    end
				--otherwise, queue if the character associated with the vcd is talking
				else
					if characterCurscene(SceneTable[arg].char)~=nil then
				 		QueueAdd(arg)
			 			return
                    end
			 	end
			end	
        end
	  
		if scenequeue_AddScene(arg,SceneTable[arg].char) == nil then
			return
        end
		inst = scenequeue[arg]
		inst.waitSceneStart = sceneStart
		
		if SceneTable[arg].idle then
			nags_init(inst,arg)
        end

		--This is a new dialog block, so turn off special processing
		dingon=true
		pitchShifting = false
		--startBlock = Time()
		if SceneTable[arg].noDingOff then
			inst.waitNoDingOff = true
		else
			inst.waitNoDingOff = false
        end
		if SceneTable[arg].noDingOn then
			inst.waitNoDingOn = true
		else
			inst.waitNoDingOn = false
        end	
	end
	
	local preDelay = 0.00
	--If this vcd wasn't called after a predelay (meaning the predelay already happened), see if there is a predelay
	if not inst.waitPreDelayed then
		preDelay = EvaluateTimeKey("predelay", SceneTable[arg])
		if SceneTable[arg].fromqueue and SceneTable[arg].queuepredelay then
			preDelay = EvaluateTimeKey("queuepredelay", SceneTable[arg])
        end
		--If there is a predelay, set it and then GladosThink() will fire it after predelay seconds.
		if preDelay > 0.00 then
			inst.waitPreDelayed = true
			inst.waitDelayingUntil = CurTime()+preDelay
			inst.waitPreDelayedEntry = arg
			printlDBG("======= "..arg.." PREDELAYED FOR "..preDelay.." SECONDS")
			return
        end
	--Otherwise, set the PreDelayed flag to false	
	else
		inst.waitPreDelayed = false
		inst.waitPreDelayedEntry = nil
    end
	
	--If this scene is a nag/idle cycle, grab the next line off the stack
	if inst.isNag then
		--If we're not in a vcd chain, grab the next vcd from the randomized pool
		if not inst.naginchain then
			arg = nags_fetch(inst)
        end
		--if nothing fetched (because the nag has used all the lines and isn't marked as "repeat"), remove this scene
		if arg == nil then
			scenequeue_DeleteScene(inst.index)
			return
        end
	end
	
	--Set ducking volume correctly for booming glados audio
	--RunConsoleCommand( "snd_ducktovolume 0.2" )
	
  --SetDucking( "announcerVOLayer", "announcerVO", 0.01 ) 
  --SetDucking( "gladosVOLayer", "gladosVO", 0.1 ) 

	if arg ~= nil then

		local ltalkover
		ltalkover = SceneTable[arg].talkover

		--Cancel any vcd that's already playing
		if not ltalkover then
			GladosAllCharactersStopScene()
		else
			--characters can't currently talk over themselves
			GladosCharacterStopScene(SceneTable[arg].char)
        end
		
		--Play the initial ding (unless the scene specifically requests no ding)
		if dingon and not inst.waitNoDingOn then
			EntFireByHandle( sceneDingOn, "Start", "", 0.00, nil, nil )
        end

		
		--Start the new vcd	
		printlDBG("===================Playing:" .. arg)
		inst.currentCharacter = SceneTable[arg].char
		
		--Bind the OnCompletion Event
		--SceneTable[arg].vcd:ValidateScriptScope()
		--SceneTable[arg].vcd:GetScriptScope().PlayNextScene = PlayNextScene:bindenv(self)
		--SceneTable[arg].vcd:DisconnectOutput( "OnCompletion", "PlayNextScene" )
		--SceneTable[arg].vcd:ConnectOutput( "OnCompletion", "PlayNextScene" )
		--SceneTable[arg].vcd:ConnectOutput( "OnCanceled", "SceneCanceled" )
		
		--Set the target1 if necessary
		if caller ~= nil then
			if type(caller) == "string" then
				EntFireByHandle( SceneTable[arg].vcd, "SetTarget1", caller, 0, nil, nil )
				printlDBG("++++++++++++SETTING TARGET: "..caller)
			else
				EntFireByHandle( SceneTable[arg].vcd, "SetTarget1", caller.GetName(), 0, nil, nil )
            end
		end
		if SceneTable[arg].settarget1 then
			printlDBG("++++++++++++ "..arg.."SETTING TARGET: "..SceneTable[arg].settarget1)
			EntFireByHandle( SceneTable[arg].vcd, "SetTarget1", SceneTable[arg].settarget1 , 0, nil, nil )
        end

		inst.waitVcdTeam = SceneTable[arg].index
		inst.waitVcdCurrent = arg
		
		inst:addFiredVcd(SceneTable[arg].index)
				
		if dingon and not inst.waitNoDingOn then
			EntFireByHandle( SceneTable[arg].vcd, "Start", "", 0.00+0.18, nil, nil )
		else	
			EntFireByHandle( SceneTable[arg].vcd, "Start", "", 0.00, nil, nil )
        end
		
		--Does this vcd have a "fire into entities" array?
		if SceneTable[arg].fires then
			local idx, val
			for idx, val in ipairs(SceneTable[arg].fires) do
				if val.fireatstart then
					printlDBG(">>>>>>ENT FIRE AT START: "..val.entity..":"..val.input)
					EntFire(val.entity,val.input,val.parameter, val.delay)
                end
			end
		end

		if SceneTable[arg].special then
            if SceneTable[arg].special == 1 then
                pitchShifting = true
            elseif SceneTable[arg].special == 2 then
                if pitchOverride == nil then
                    EntFireByHandle(SceneTable[arg].vcd, "PitchShift", "2.5", 0, nil, nil)
                end
            elseif SceneTable[arg].special == 3 then
                EntFireByHandle(SceneTable[arg].vcd, "PitchShift", "0.9", 0, nil, nil)
            end
        end
		if pitchOverride~=nil then
			EntFireByHandle( SceneTable[arg].vcd, "PitchShift", tostring(pitchOverride), 0, nil, nil )
        end
    end
    --Setup next line (if there is one)
    if SceneTable[arg].next ~= nil or inst.isNag then
    	local pdelay = EvaluateTimeKey("postdelay",SceneTable[arg])
    	
    	--if this is a nag, use min/max defined in the first entry in the scene
    	if inst.isNag then
    		pdelay = math.Rand(inst.nagminsecs,inst.nagmaxsecs)

    	if pdelay<0.00 then
    		    if inst.isNag then
                    -- If the "next" key ~= nil, it means we're in a vcd chain
                    if SceneTable[arg].next ~= nil then
                        inst.waitNext = SceneTable[arg].next
                        inst.naginchain = true
                    else
                        -- Otherwise, just slug in the same index (any non-nil value would work here)
                        inst.waitNext = arg
                        inst.naginchain = false
                    end
                else
                    inst.waitNext = SceneTable[arg].next
                end

 				inst.waitExitingEarly=true
 				inst.waitLength=nil
 				inst.waitExitingEarlyStartTime=CurTime()
				--If we're in a nag vcd chain, use the vcds postdelay rather than the nag-wide delay
				--This is because vcd chains generally need to be explicitly timed at the chain level
				--since the vcds are grouped together as a block
 				if inst.naginchain then
 					pdelay = EvaluateTimeKey("postdelay",SceneTable[arg])
                end
 				inst.waitExitingEarlyThreshold=pdelay*-1
			else
 				inst.waitExitingEarly=false
            end
    		if inst.isNag then
    			--If the "next" key != nil, it means we're in a vcd chain
    			if SceneTable[arg].next ~= nil then
    				inst.waitNext = SceneTable[arg].next
    				inst.naginchain = true
    			else
    				--Otherwise, just slug in the same index (any non-nil value would work here, however)
					inst.waitNext = arg
    				inst.naginchain = false
				end
    		else
				inst.waitNext = SceneTable[arg].next 
				--If we're in a nag vcd chain, use the vcds postdelay rather than the nag-wide delay
				--This is because vcd chains generally need to be explicitly timed at the chain level
				--since the vcds are grouped together as a block
 				if inst.naginchain then
 					pdelay = EvaluateTimeKey("postdelay",SceneTable[arg])
                end
			end
   		inst.waitLength = pdelay
    end	
		else
			inst.waitNext = nil
			printlDBG("===================SCENE END")
        end
end

function EvaluateTimeKey(keyname, keytable)
    local ret

    local v = keytable[keyname]
    if v ~= nil then
        local typ = type(v)
        if typ == "table" then
            -- GLua: arrays are 1-based
            -- Expect {min, max}
            if #v ~= 2 then
                printlDBG("!!!!!!!!!!!!EVALUATE TIME KEY ERROR: "..keyname.." is an array with a length ~= 2")
                return 0.00
            end
            ret = math.Rand(v[1], v[2])
        else
            -- assume it's a number
            ret = v
        end
    end

    if ret == nil then
        ret = 0.00
    end

    printlDBG(">>>>>>>>>EVALUATE TIME KEY: "..keyname.." : "..ret)
    return ret
end


function GladosToggleDBG(arg)
    arg = arg or nil
	DBG = !DBG
	if DBG then
		print("======================GLaDOS DBG ON")
	else
		print("======================GLaDOS DBG OFF")
    end
	if arg~=nil then
		DBGInterval = arg
    end
end

function GladosSetPitch(arg)
	pitchOverride = arg
	local curscene = self:GetCurrentScene()
	if curscene ~= nil then
		EntFire( curscene, "PitchShift", tostring(pitchOverride), 0, nil, nil )
    end
end


--Nukes Everything. Delete all currently playing & queued scenes.
function nuke()
	scenequeue = {}
	Queue = {}
	GladosAllCharactersStopScene()
	StopAllCaveSpeakers()
end

--Checks each cave speaker actor to see if it's playing a vcd and stops it if it is.
function StopAllCaveSpeakers()
    --[[
    local caveactors = {
        "@cave_exit_lift",
        "cave_a3_03_dummy",
        "cave_a3_03_dummy2",
        "cave_a3_03_dummy3",
        "cave_a3_03_exit",
        "cave_a3_03_lift_shaft",
        "cave_a3_03_waiting_room",
        "cave_a3_jump_intro_entrance",
        "cave_a3_jump_intro_interchamber",
        "cave_a3_jump_intro_second_chamber",
        "cave_a3_transition01_dummy",
        "cave_a3_transition01_dummy2",
        "cave_a3_transition01_dummy3",
        "cave_bomb_flings_chamber",
        "cave_bomb_flings_entrance",
        "cave_crazy_box_2nd_chamber",
        "cave_crazy_box_dummy_chamber",
        "cave_crazy_box_entrance",
        "cave_portal_intro_entrance",
        "cave_portal_intro_exit",
        "cave_portal_intro_office",
        "cave_portal_intro_whitepaint",
        "cave_speed_flings_entrance",
        "cave_speed_ramp_entrance",
        "cave_speed_ramp_inter_chamber",
        "cave_transition01_dummy_exit",
        "cave_transition01_welcome"
    }

    for _, name in ipairs(caveactors) do
        local ent = nil
        ent = ents.FindByName(ent, name)
        if ent ~= nil then
            local sc = ent.GetCurrentScene and ent:GetCurrentScene() or nil
            if sc ~= nil then
                EntFire(sc, "Cancel", "", 0, nil, nil)
            end
        end
    end
    ]]
end


--Stops a scene for all characters
function GladosAllCharactersStopScene()
	GladosCharacterStopScene("glados")
	GladosCharacterStopScene("wheatley")
	GladosCharacterStopScene("cave_body")
	GladosCharacterStopScene("core01")
	GladosCharacterStopScene("core02")
	GladosCharacterStopScene("core03")
end

function characterCurscene(arg)
    local ret = nil
    local ent = nil

    if arg == "bossannouncer" then
        ent = ents.FindByName("@actor_announcer")
    elseif arg == "announcerglados" or arg == "glados" or arg == "@glados" then
        ent = ents.FindByName("@glados")
    elseif arg == "cave" or arg == "@cave" then
        ent = ents.FindByName("@cave")
    elseif arg == "wheatley" or arg == "sphere" or arg == "@sphere" then
        ent = ents.FindByName("@sphere")
    elseif arg == "core01" or arg == "@core01" then
        ent = ents.FindByName("@core01")
    elseif arg == "core02" or arg == "@core02" then
        ent = ents.FindByName("@core02")
    elseif arg == "core03" or arg == "@core03" then
        ent = ents.FindByName("@core03")
    elseif arg == "cave_body" or arg == "cavebody" then
        ent = ents.FindByName("@cave_body")
    elseif arg == "conveyor_turret" then
        ent = ents.FindByName("conveyor_turret_body")
    end

    if ent ~= nil then
        printlDBG("&&&&&&FOUND ENTITY: " .. arg)
        ret = ent.GetCurrentScene and ent:GetCurrentScene() or nil
    end

    return ret
end

--Stops a scene for a particular character
function GladosCharacterStopScene(arg)
    local ent = nil
    local curscene = characterCurscene(arg)
    
    if curscene ~= nil then
        printlDBG("&&&&&&STOP SCENE: " .. arg .. " FOUND SCENE TO DELETE!!!!!!!!!")
        EntFire(curscene, "Cancel", "", 0, nil, nil)
    else    
        printlDBG("&&&&&&STOP SCENE: NO SCENE TO DELETE FOR " .. arg)
    end
end

-- Turns off current Glados speech
function GladosStopTalking(ent)
    local curscene = ent and ent.GetCurrentScene and ent:GetCurrentScene() or nil
    pitchOverride = nil
    waitNext = nil
    waitLength = nil
    if curscene ~= nil then
        EntFire(curscene, "Cancel", "", 0, nil, nil)
    end
end

-- Turns off current Glados speech if the scene # passed as arg is currently playing
function GladosStopScene(ent, arg)
    if waitSceneStart == arg then
        local curscene = ent and ent.GetCurrentScene and ent:GetCurrentScene() or nil
        pitchOverride = nil
        waiting = 0
        waitNext = nil
        waitLength = nil
        if curscene ~= nil then
            EntFire(curscene, "Cancel", "", 0, nil, nil)
        end
    end
end

-- Slowfield functions
function GladosEndSlowFieldTraining(ent)
    stateSlowFieldTraining = false
    GladosStopTalking(ent)
end

function GladosStartSlowFieldTraining()
    stateSlowFieldTraining = true
    GladosPlayVcd(40)
end

function GladosSlowFieldOn()
    if stateSlowFieldTraining then
        GladosPlayVcd(41)
    end
end

function GladosSlowFieldOff()
    if stateSlowFieldTraining then
        GladosPlayVcd(40)
    end
end
-- End of Slowfield functions

-- Special Chamber Processing
function GladosRelaxationVaultPowerUp()
    EntFire("open_portal_relay", "Trigger", "", 0.0)
end


------------------------------------------------------------------------------------------------------------------
-- Automated dialog lookup
------------------------------------------------------------------------------------------------------------------

function MapNameConversion(orgname)
    if MapBspConversion[orgname] ~= nil then
        return MapBspConversion[orgname]
    else
        return orgname
    end
end


GladosDialog =
{
	{ map = "sp_a1_intro2", prestart = "PreHub01PortalCarouselEntry01", completed = "PreHub01PortalCarouselSuccess01" },
	{ map = "sp_a1_intro3", prestart = "sp_intro_03Start01", completed = "sp_intro_03MindTheGapFinish01" },
	{ map = "sp_a1_intro4", start = "PreHub01BoxDropperEntry01", completed = "sp_a1_intro4End01" },
	--{ map = "sp_a1_intro5", start = "PreHub01DualButtonOnePortalEntry01", completed = "PreHub01DualButtonOnePortalSuccessB01" },
	{ map = "sp_a1_intro5", start = "sp_a1_intro5Start01", completed = "PreHub01DualButtonOnePortalSuccessB01" },
	{ map = "sp_a1_intro6", start = "sp_a1_intro6Start01", completed = "sp_a1_intro6End01" },
	{ map = "sp_a1_intro7", prestart = "sp_a1_intro7Start01" },
	--{ map = "sp_incinerator_01", exitstarted = "sp_incinerator_01Elevator01" },
	{ map = "sp_laser_redirect_intro", start = "sp_laser_redirect_introStart01", completed = "sp_laser_redirect_introEnd01" },
	{ map = "sp_laser_stairs", start = "sp_laser_stairsStart01", completed = "sp_laser_stairsEnd01" },
	{ map = "sp_laser_dual_lasers", prestart = "sp_laser_dual_lasersStart01", completed = "sp_laser_dual_lasersEnd01" },
	{ map = "sp_laser_over_goo", start = "sp_laser_over_gooStart01", completed = "sp_laser_over_gooEnd01" },
	{ map = "sp_catapult_intro", completed = "sp_catapult_introEnd01" },
	{ map = "sp_trust_fling", prestart = "sp_trust_flingStart01", completed = "sp_trust_flingEnd01" },
	{ map = "sp_a2_pit_flings", prestart = "sp_a2_pit_flingsStart01", completed = "sp_a2_pit_flingsCubeSmuggleEnding01" },
	{ map = "sp_a2_fizzler_intro", start = "sp_a2_fizzler_introStart01" },
	{ map = "sp_catapult_fling_sphere_peek", completed = "sp_catapult_fling_sphere_peekEnd01" },
	{ map = "sp_a2_ricochet", prestart = "sp_a2_ricochetStart01", completed = "sp_a2_ricochetEnd01" },
	{ map = "sp_bridge_intro", completed = "sp_bridge_introEnd01" },
	{ map = "sp_bridge_the_gap", prestart = "sp_bridge_the_gapStart01", completed = "sp_bridge_the_gapEnd01" },
	{ map = "sp_turret_training_advanced", prestart = "sp_turret_training_advancedStart01" },
	{ map = "sp_laser_relays", prestart = "sp_laser_relaysStart01", completed = "sp_laser_relaysEnd01" },
	{ map = "sp_a2_turret_blocker", prestart = "sp_turret_blocker_introStart01", completed = "sp_turret_blocker_introEnd01" },
	{ map = "sp_laser_vs_turret_intro", prestart = "sp_laser_vs_turret_introStart01", completed = "sp_laser_vs_turret_introEnd01" },
	{ map = "sp_a2_pull_the_rug", prestart = "sp_a2_pull_the_rugStart01", completed = "sp_a2_pull_the_rugEnd01" },
	--RING AROUND THE TURRETS NO LONGER IN THE TRACK
	--{ map = "sp_ring_around_the_turrets", completed = "sp_ring_around_the_turretsEnd01" },
	{ map = "sp_column_blocker", completed = "sp_column_blockerEnd01" },
	{ map = "sp_a2_laser_chaining", prestart = "sp_a2_laser_chainingStart01", completed = "sp_a2_laser_chainingEnd01" },
	--Turret Tower no longer in track
	--{ map = "sp_turret_tower", prestart = "sp_turret_towerStart01", completed = "sp_turret_towerEnd01" },
	{ map = "sp_a2_triple_laser", start = "sp_a2_triple_laserStart01", completed = "sp_a2_triple_laserEnd01" },
	{ map = "sp_sabotage_jailbreak", prestart = "sp_sabotage_jailbreakStart01" },
	{ map = "sp_a3_speed_ramp", prestart = "-3150_01" },
	{ map = "sp_a4_finale3", prestart = "-4849_01" },
}

--Generic glados dialog functions.
--PuzzleStart fires automatically as the player moves out of the level transition area
function PuzzleStart()
    printlDBG("===============In Puzzle Start " .. game.GetMap())

    local mpco
    for index, level in ipairs(GladosDialog) do
        mpco = MapNameConversion(level.map)

        if (level.map == game.GetMap() or mpco == game.GetMap()) and level.start ~= nil then
            print("===============PuzzleStart: playing scene " .. tostring(level.start))
            GladosPlayVcd(level.start)
        end
    end
end

--PuzzlePreStart fires just after the level load
function PuzzlePreStart()
    printlDBG("===============In Puzzle PreStart")

    local mpco
    for index, level in ipairs(GladosDialog) do
        mpco = MapNameConversion(level.map)

        if (level.map == game.GetMap() or mpco == game.GetMap()) and level.prestart ~= nil then
            printlDBG("===============PuzzlePreStart: playing scene " .. tostring(level.prestart))
            GladosPlayVcd(level.prestart)
        end
    end
end

didLeftElevatorChamber = false

function LeftElevatorChamber()
    if not didLeftElevatorChamber then
        didLeftElevatorChamber = true

        local mpco
        for index, level in ipairs(GladosDialog) do
            mpco = MapNameConversion(level.map)

            if (level.map == game.GetMap() or mpco == game.GetMap()) and level.leftelevatorchamber ~= nil then
                printlDBG("===============LeftElevatorChamber: playing scene " .. tostring(level.leftelevatorchamber))
                GladosPlayVcd(level.leftelevatorchamber)
            end
        end
    end
end

--ExitStarted fires when the exit elevator doors close
function ExitStarted()
    printlDBG("===============In Puzzle ExitStarted")

    for _, level in ipairs(GladosDialog) do
        local mpco = MapNameConversion(level.map)

        if (level.map == game.GetMap() or mpco == game.GetMap()) and level.exitstarted then
            printlDBG("===============ExitStarted: playing scene " .. level.exitstarted)
            GladosPlayVcd(level.exitstarted)
        end
    end
end

--PuzzleCompleted fires when the glados exit speech is supposed to trigger. It isn't fired automatically from an instance.
--It needs to fire from a trigger in the map
function PuzzleCompleted()
    for index, level in ipairs(GladosDialog) do
        local mpco = MapNameConversion(level.map)
        if (level.map == game.GetMap() or mpco == game.GetMap()) and level.completed ~= nil then
            printlDBG("===============PuzzleCompleted: playing scene " .. level.completed)
            GladosPlayVcd(level.completed)
        end
    end
end


----------------------------------------------------------------------------------------------------------------
--Queue Functions
--	-This is the queue of scenes delayed by another scene
----------------------------------------------------------------------------------------------------------------

Queue = {}

--Initialize the queue
function QueueInitialize()
	Queue = {}
end

--Add a scene to the queue
--Queue table structure:
--	item 						= index in SceneTable (ie: SceneTable[Queue[index].item])
--	added						= time added to queue
--	queueforcesecs	= (from SceneTable) force item to play after queueforcesecs seconds in queue
--	queuetimeout		= (from SceneTable) delete item if it sits in queue for queuetimeout seconds
--	queuepredelay		= (from SceneTable) wait queuepredelay seconds to fire the scene if it sat in the queue for any amount of time
function QueueAdd(arg)
    Queue[#Queue + 1] = { item = arg, added = CurTime() }

    if SceneTable[arg] then
        local last = Queue[#Queue]

        if SceneTable[arg].queueforcesecs then
            last.queueforcesecs = SceneTable[arg].queueforcesecs
        else
            last.queueforcesecs = 45.0
        end

        if SceneTable[arg].queuetimeout then
            last.queuetimeout = SceneTable[arg].queuetimeout
        end

        if SceneTable[arg].queuepredelay then
            last.queuepredelay = SceneTable[arg].queuepredelay
        end
    end
end

--Returns number of items in the queue
function QueueLen(char)
    char = char or nil
	local i = 0
	if char == nil then
		return Queue.len()
	else
		for index, scene in ipairs(Queue) do
			if SceneTable[scene.item].char == char then
				i = i + 1
            end
		end
		return i
	end
end

--Fetch the next scene in the queue
-- Get the next item from the queue
function QueueGetNext()
    local ret = nil
    local l = QueueLen()
    if l > 0 then
        ret = Queue[l].item
        table.remove(Queue, l)
    end
    return ret
end

-- DBG print the queue
function QueueDBG()
    printlDBG("=================== items in queue -> " .. #Queue)
    for index, scene in ipairs(Queue) do
        if SceneTable[scene.item] then
            printlDBG("========= queue item " .. index .. " (" .. scene.item .. "): character " .. SceneTable[scene.item].char)
        end
    end
end

-- Process the queue, removing timed-out items and returning any ready to force-fire
function QueueThink()
	local ret,t,index
	if QueueLen() == 0 then
		return nil
    end
	
	t=CurTime()
	//Check to see if any queued scenes timed out
	for index = QueueLen(), 0, -1 do
 		if Queue[index-1].queuetimeout then
 			if t-Queue[index-1].added > Queue[index-1].queuetimeout then
 				Queue[index - 1] = nil
            end
 		end
	end

	//Check to see if any queued scenes should force fire
	for index, scene in ipairs(Queue) do
 		if scene.queueforcesecs then
 			if t-scene.added >scene.queueforcesecs then
 				ret = scene.item
 				Queue[index] = nil
 				return ret
            end
 		end
	end
	return nil
end

--DBG testbed function
-- QueueTest function
function QueueTest()
    local a = {}

    -- Fill the table with random numbers
    for i = 0, 9 do
        table.insert(a, math.random(1, 100))
        print(">>>>>> " .. i .. " : " .. a[i + 1]) -- Lua tables are 1-indexed
    end

    -- Remove numbers less than 50
    for i = #a, 1, -1 do
        if a[i] < 50 then
            table.remove(a, i)
        end
    end

    -- Print the remaining elements
    for index, n in ipairs(a) do
        print(">>>>>> " .. index .. " : " .. n)
    end
end

-- Delete a single item from the queue
function QueueDeleteItem(item)
    if QueueLen() == 0 then
        return false
    end

    for index, scene in ipairs(Queue) do
        if scene.item == item then
            table.remove(Queue, index)
            return true
        end
    end

    return false
end

-- Check and fire a queued scene
function QueueCheck()
    if QueueLen() > 0 then
        print("===QUEUE LEN IS " .. QueueLen())
        local tmp = QueueGetNext()
        if tmp ~= nil then
            firedfromqueue = true
            GladosPlayVcd(tmp, true)
            return true
        end
    end

    return false
end


----------------------------------------------------------------------------------------------------------------
--End of Queue Functions
----------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------
--sp_sabotage_jailbreak specific functions 
----------------------------------------------------------------------------------------------------------------

function jailbreak_alert(arg)
	jailbreakpos = arg
	printlDBG("==========JAILBREAK ALERT " .. arg)
end

function jailbreak_whoah_speech()
	if jailbreakpos == 0 then
		GladosPlayVcd(303)
	else
		GladosPlayVcd(302)
	end
end


----------------------------------------------------------------------------------------------------------------
--sp_sabotage_darkness specific functions 
----------------------------------------------------------------------------------------------------------------


function PlayGhostStory()
	GladosPlayVcd(445)
end

function PlaySmellyHumansOne()
	GladosPlayVcd(446)
end

function PlaySmellyHumansTwo()
	GladosPlayVcd(447)
end
 
function PlaySmellyHumansThree()
	GladosPlayVcd(448)
end

function PlaySmellyHumansFour()
	GladosPlayVcd(449)
end


----------------------------------------------------------------------------------------------------------------
--Glados Battle specific functions 
----------------------------------------------------------------------------------------------------------------

-- Initialize variables
glados_gibbering = false
glados_gibbering_start = CurTime()
glados_gibbering_next = 0.00
glados_gibbering_times = {}

glados_gibbering_times[1] = 0.7
glados_gibbering_times[2] = 1.37
glados_gibbering_times[3] = 1.22
glados_gibbering_times[4] = 1.27
glados_gibbering_times[5] = 5.29
glados_gibbering_times[6] = 4.15
glados_gibbering_times[7] = 3.35

-- Example map-specific variable
if curMapName == "sp_a2_core" then
    sp_a2_core_xfer_left_annex = false
end

-- Start GLaDOS gibberish
function sp_sabotage_glados_start_gibberish()
    -- Gibberish is off for now
    -- glados_gibbering = true
    glados_gibbering_start = CurTime()
    glados_gibbering_next = 0.00
end

-- Stop GLaDOS gibberish
function sp_sabotage_glados_stop_gibberish()
    glados_gibbering = false
end

-- Play GLaDOS gibberish
function sp_sabotage_glados_gibberish()
    local i = math.random(1, 7) -- RandomInt equivalent in Lua
    if CurTime() - glados_gibbering_start > glados_gibbering_next then
        RunConsoleCommand("scene_playvcd", "npc/glados/sp_sabotage_glados_gibberish0" .. i)
        glados_gibbering_start = CurTime()
        -- glados_gibbering_next = math.Rand(3.5, 5.0) -- optional random
        glados_gibbering_next = glados_gibbering_times[i]
    end
end




-- ==============================
-- player starts vault trap
-- ==============================
function VaultTrapStart()
	GladosPlayVcd(-50)
end

-- ==============================
-- player begins moving in relaxation vault
-- ==============================
function VaultTrapStartMoving() 
	GladosPlayVcd(-53)
end

-- ==============================
-- turrets are on the ground and begin their scene
-- ==============================
function TurretScene()
	GladosPlayVcd(-700)
end
 
-- ==============================
-- ==============================
function TurretDeathReactionDialog()
	GladosPlayVcd(-57)
	--gladosbattle_pre_05 -- my turrets!
	--gladosbattle_pre_06 -- oh, you were busy back there
	--gladosbattle_pre_17 -- i suppose we could just sit here and glare ... but i have a better idea
end



-- ==============================
-- ==============================
function WheatleyBouncingDownTubeDialog()
	-- play various "ouch.. oof... ow..." lines here
	-- play glados dialog responding to wheatley falling.  "...sigh..."
end


-- ==============================
-- ==============================
function WheatleyLandsInChamberDialog()
	GladosPlayVcd(-61)
	printlDBG("==========HELLO!!!!!!!!!!!!!!!!!!!!!")
	--wheatley - gladosbattle_pre01 -- Hello!
	--gladosbattle_pre_09 -- i hate you so much
end

-- ==============================
-- ==============================
function CoreDetectedDialog()
	--announcer - gladosbattle02 -- warning: core corrupted
	--glados - gladosbattle_xfer04 -- that's funny i don't feel corrupted. in fact i feel pretty good
	--announcer - gladosbattle03 -- alternate core detected
	--wheatley pre05  -- ah that's me they're talking about!
	--announcer - gladosbattle03 -- to initiate a core transfer deposit core in receptacle
	--ent_fire "deploy_core_receptacle_relay" trigger -- deploys the core receptacle
	--glados - gladosbattle_xfer05 -- core transfer?
	--glados - gladosbattle_xfer06 -- oh you are kidding me
	
end


-- ==============================
-- ==============================
function WheatleyCoreSocketed()

	StopWheatleyPluginNag()
	GladosPlayVcd(-71) -- announcer - substitute core accepted.  core, are you willing to start the procedure?
	
end

-- ==============================
--	called when the player reaches a catapult or enters the room to press stalemate button
-- ==============================
function StalemateAssociateNotSoFast()
	StopWheatleyPluginNag()
	GladosPlayVcd(-84)
end


-- ==============================
-- ==============================
function CoreTransferInitiated()
	-- start the core particle system
	nuke()
	EntFire("glados_shutdown_particles_relay", "trigger", 0, 0 )
	GladosPlayVcd(-88) --Stalemate Resolved. Core Transfer Initiated.
end

-- ==============================
-- ==============================
function WheatleyCoreTransferStart()
	sp_a2_core_xfer_left_annex = true
	--nuke()
	GladosPlayVcd(-4) -- Here I go!
end

function sp_a2_core_leave_annex_nag()
	if not sp_a2_core_xfer_left_annex then
		GladosPlayVcd(-45)
	end
end

-- ==============================
-- ==============================
function PitHandsGrabGladosHead()
	GladosPlayVcd(-89) -- Get your hands off me!
end

-- ==============================
-- ==============================
function PullGladosIntoPit()
	GladosPlayVcd(-90) -- CHELL! STOP THIS! I AM YOUR MOTHER!
end

-- ==============================
-- ==============================
function CoreTransferCompleted()
	GladosPlayVcd(-9)  -- Wow! Check ME out, Partner! .. Look how small you are!
end

-- ==============================
-- ==============================
function PlayerEnteredElevator()
	StopWheatleyElevatorNag()
	CorePlayerInElevator = 1 -- this will prevent the elevator nag from being triggered by subsequent IO
	EntFire("@exit_elevator_music_relay","trigger", 0, 0 )
	GladosPlayVcd(-13) -- I knew it was going to be cool being in charge..
	
	-- delete many of the small_pos arms
	EntFire("small_pos1", "kill", 0, 0 )
	EntFire("small_pos3", "kill", 0, 0 )
	EntFire("small_pos4", "kill", 0, 0 )
	EntFire("small_pos7", "kill", 0, 0 )
	EntFire("small_pos9", "kill", 0, 0 )
	EntFire("small_pos10", "kill", 0, 0 )
end


-- ==============================
-- ==============================
function DialogDuringPotatosManufacture()
	GladosPlayVcd(-33)
end

-- ==============================
-- ==============================
function PotatosPresentation()
	GladosPlayVcd(-34)
end

-- ==============================
-- ==============================
function ElevatorMoronScene()
	GladosPlayVcd(-37)
end

-- ==============================
-- ==============================
function ElevatorConclusion()
	GladosPlayVcd(-44)
end


----------------------------------------------------------------------------------------------------------------
--sp_sabotage_factory functions 
----------------------------------------------------------------------------------------------------------------

function sabotage_factory_WatchTheLine()
	GladosPlayVcd(441)
end

function sabotage_factory_ReachedHackingSpot()
	GladosPlayVcd(442)
end

function sabotage_factory_PlayerReachedWheatley()
	WheatleyStopNag()
	GladosPlayVcd(443)
end

function sabotage_factory_PlayerReachedExitDoor()
	WheatleyStopNag()
	GladosPlayVcd(444)
end


----------------------------------------------------------------------------------------------------------------
--sp_sabotage_factory - Science Fair functions 
----------------------------------------------------------------------------------------------------------------
function ScienceFairGoingTheRightWay()
	GladosPlayVcd( -100 )
end

function ScienceFairBringDaughter()
	GladosPlayVcd( -101 )
end

function JustToReassureYou()
	GladosPlayVcd( -102 )
end

function DefinitelySureThisWay()
	GladosPlayVcd( -103 )
end


----------------------------------------------------------------------------------------------------------------
--sp_catapult_fling_sphere_peek functions 
----------------------------------------------------------------------------------------------------------------

function sp_catapult_fling_sphere_peek()
    if peekctr == 0 then
        GladosPlayVcd(335)
    elseif peekctr == 2 then
        GladosPlayVcd(362)
    elseif peekctr == 4 then
        GladosPlayVcd(363)
    end

    peekctr = peekctr + 1
end


----------------------------------------------------------------------------------------------------------------
--New test functions 
----------------------------------------------------------------------------------------------------------------
function GladosTest1(arg)
    -- Iterate backwards to safely remove items while looping
    for i = #arg, 1, -1 do
        local scene = arg[i]
        if scene.item then
            table.remove(arg, i)
        end
    end
end


----------------------------------------------------------------------------------------------------------------
--Scenes List Functions START
--	-This is the list of currently playing scenes
----------------------------------------------------------------------------------------------------------------
local scene = {}
scene.__index = scene

-- constructor
function scene:new(a, caller)
    local obj = setmetatable({}, self)

    -- scalar fields
    obj.index                     = a or 0
    obj.owner                     = caller or nil
    obj.currentCharacter          = ""
    obj.waitSceneStart            = 0
    obj.waiting                   = 0
    obj.waitVcdCurrent            = nil
    obj.waitStartTime             = CurTime()
    obj.waitLength                = CurTime()
    obj.waitNext                  = nil
    obj.waitExitingEarly          = false
    obj.waitExitingEarlyStartTime = CurTime()
    obj.waitExitingEarlyThreshold = 0.00
    obj.waitDelayingUntil         = nil
    obj.waitPreDelayed            = false
    obj.waitPreDelayedEntry       = nil
    obj.waitNoDingOff             = false
    obj.waitNoDingOn              = false
    obj.waitVcdTeam               = -1

    obj.nagminsecs                = 0
    obj.nagmaxsecs                = 0
    obj.isNag                     = false
    obj.naglastfetched            = nil
    obj.nagrandom                 = false
    obj.nagrandomonrepeat         = false
    obj.nagtimeslistcompleted     = 0
    obj.nagrepeat                 = false
    obj.naginchain                = false

    -- per-instance tables
    obj.waitFiredVcds             = {}
    obj.waitFires                 = {}
    obj.nags                      = {}
    obj.nagpool                   = {}

    return obj
end

setmetatable(scene, {
    __call = function(cls, ...)
        return cls:new(...)
    end
})

-- METHODS -----------------------------------------

function scene:nagsClear()
    self.naglastfetched = nil

    -- GLua helper:
    -- table.Empty(self.nags)
    -- or plain Lua:
    for k in ipairs(self.nags) do
        self.nags[k] = nil
    end
end

function scene:nagpoolClear()
    -- table.Empty(self.nagpool)
    for k in ipairs(self.nagpool) do
        self.nagpool[k] = nil
    end
end

function scene:addFiredVcd(team)
    table.insert(self.waitFiredVcds, team)
end

function scene:deleteFiredVcd(team)
    for idx, val in ipairs(self.waitFiredVcds) do
        if val == team then
            table.remove(self.waitFiredVcds, idx)
            break
        end
    end
end

function scenequeue_AddScene(arg,char)
	local idx, val, delme
	delme = nil
	for idx, val in ipairs(scenequeue) do
		if SceneTable[idx].char == char then
			delme = idx
        end
		if idx == arg then
			printlDBG(">>>>>>>>>>Scene "..arg.." is already in the queue")
			return nil
        end
	end
	if delme ~= nil then
		printlDBG(">>>>>>>>>>DELETING SCENE "..delme)
		scenequeue_DeleteScene(delme)
    end
	scenequeue[arg] = scene(arg, this)
	scenequeue_Dump()
	return scenequeue[arg]
end

function scenequeue_DeleteScene(arg)
	local idx, val
	for idx, val in ipairs(scenequeue) do
		if idx == arg then
			printlDBG(">>>>>>>>>>Scene "..arg.." deleted!")
			scenequeue[arg] = nil
			return true
        end
	end
	return nil
end

function scenequeue_Dump()
	printlDBG(">>>>>>>>>>Scene Dump at ".. CurTime())
	for idx, val in ipairs(scenequeue) do
		printlDBG(">>>>>>>>>>Scene "..idx.." ADDED at "..val.waitStartTime.." Type ".. type(val))
    end
end


----------------------------------------------------------------------------------------------------------------
--Scene Queue Functions END
----------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------
--Nag Table Functions START
----------------------------------------------------------------------------------------------------------------

function nags_init(inst, scenetableentry)
    -- Clear existing nags
    inst:nagsClear()

    -- Set nag min/max seconds
    if SceneTable[scenetableentry].idleminsecs ~= nil then
        inst.nagminsecs = SceneTable[scenetableentry].idleminsecs

        if SceneTable[scenetableentry].idlemaxsecs ~= nil then
            inst.nagmaxsecs = SceneTable[scenetableentry].idlemaxsecs
        else
            inst.nagmaxsecs = inst.nagminsecs
        end
    end

    -- Set random/repeat flags
    if SceneTable[scenetableentry].idlerandomonrepeat ~= nil then
        inst.nagrandomonrepeat = true
    end
    if SceneTable[scenetableentry].idlerepeat ~= nil then
        inst.nagrepeat = true
    end
    if SceneTable[scenetableentry].idlerandom ~= nil then
        inst.nagrandom = true
    end

    local igroup = SceneTable[scenetableentry].idlegroup

    -- Iterate over all entries in SceneTable
    for idx, val in ipairs(SceneTable) do
        if val.idlegroup == nil then continue end
        if val.idlegroup ~= igroup then continue end

        local rar = 101
        local mnum = 0
        if val.idlerarity ~= nil then
            rar = val.idlerarity
        end
        if val.idlemaxplays ~= nil then
            mnum = val.idlemaxplays
        end

        -- Skip VCDs that are part of a chain (not the first link)
        if val.idleunder ~= nil then continue end

        local oig = 0
        if val.idleorderingroup ~= nil then
            oig = val.idleorderingroup
        end

        table.insert(inst.nags, {
            SceneTableIndex = idx,
            rarity = rar,
            maxplays = mnum,
            totplays = 0,
            orderingroup = oig
        })
    end

    -- Sort the nags
    table.sort(inst.nags, function(a, b)
        return nag_array_compare(a, b) < 0
    end)

    -- Initialize nagging state
    inst.isNag = true
    inst.nagtimeslistcompleted = 0

    -- Create the nag pool
    nags_createpool(inst)
end

function nags_createpool(inst)
    -- Clear the current nag pool
    inst:nagpoolClear()

    local tempa = {}

    -- Build a temporary pool of eligible nags
    for _, val in ipairs(inst.nags) do
        local takeit = false

        -- Only proceed if maxplays not reached
        if not (val.maxplays > 0 and val.totplays >= val.maxplays) then
            -- Roll for rarity
            if math.random(1, 100) < val.rarity then
                takeit = true
            end

            if takeit then
                table.insert(tempa, val)
            end
        end
    end

    -- If pool is empty, exit
    if #tempa == 0 then return end

    -- Randomize the pool if necessary
    if inst.nagrandom or (inst.nagrandomonrepeat and inst.nagtimeslistcompleted > 0) then
        -- Ensure first entry is not the same as last fetched
        if #tempa > 1 and inst.naglastfetched ~= nil then
            while true do
                local r = math.random(1, #tempa)
                if tempa[r].SceneTableIndex ~= inst.naglastfetched then
                    table.insert(inst.nagpool, tempa[r])
                    table.remove(tempa, r)
                    break
                end
            end
        end

        -- Add the rest of the pool randomly
        while #tempa > 0 do
            local r = math.random(1, #tempa)
            table.insert(inst.nagpool, tempa[r])
            table.remove(tempa, r)
        end
    else
        -- Simply append in order
        for _, val in ipairs(tempa) do
            table.insert(inst.nagpool, val)
        end
    end
end


function nags_nagpooldump(inst)
    for idx, val in ipairs(inst.nagpool) do
        print("[DBG] *********NAG " .. idx .. " : " .. val.SceneTableIndex)
    end
end

function nags_fetch(inst)
    -- Check if the nag pool is empty
    if #inst.nagpool == 0 then
        if inst.nagrepeat then
            inst.nagtimeslistcompleted = inst.nagtimeslistcompleted + 1
            nags_createpool(inst)
            if #inst.nagpool == 0 then
                return nil
            end
        else
            return nil
        end
    end

    -- Fetch the first item from the pool
    local ret = inst.nagpool[1].SceneTableIndex  -- Lua tables are 1-indexed

    -- Increment totplays in the main nags list
    for idx, val in ipairs(inst.nags) do
        if val.SceneTableIndex == ret then
            val.totplays = val.totplays + 1
            break
        end
    end

    -- Remove the first item from the pool
    table.remove(inst.nagpool, 1)

    -- Store the last fetched index
    inst.naglastfetched = ret

    return ret
end

function GladosStopNag(arg)
    arg = 0
	nag_stop("glados",arg)
end

function WheatleyStopNag(arg)
    arg = 0
	nag_stop("wheatley",arg)
end

function Core01StopNag(arg)
    arg = 0
	nag_stop("core01",arg)
end

function Core02StopNag(arg)
    arg = 0
	nag_stop("core02",arg)
end

function Core03StopNag(arg)
    arg = 0
	nag_stop("core03",arg)
end


function nag_stop(char, stoptype)
	local idx, val
	local todel = nil
	for idx, val in ipairs(scenequeue) do
		if val.isNag and val.currentCharacter == char  then
			todel=idx
			break
		end
	end
	if todel ~= nil then
		scenequeue_DeleteScene(todel)	
	end
end

function nag_array_compare(a, b)
    if a.orderingroup > b.orderingroup then
        return 1
    elseif a.orderingroup < b.orderingroup then
        return -1
    end
    return 0
end


----------------------------------------------------------------------------------------------------------------
--Nag Table Functions END
----------------------------------------------------------------------------------------------------------------


function TrustFlingCatapultTurretNoticesPlayer()
	GladosPlayVcd(439, nil, "catapulted_turret")
end

----------------------------------------------------------------------------------------------------------------
--Elevator Stoppage in bridge over goo
----------------------------------------------------------------------------------------------------------------

function sp_a2_laser_over_goo_elevator_stoppage()
	GladosPlayVcd(465)
	-- @trigger_this_to_stop_elevator
	-- @trigger_this_to_start_elevator
end


----------------------------------------------------------------------------------------------------------------
--sp_a1_intro7 functions
----------------------------------------------------------------------------------------------------------------
if curMapName=="sp_a1_intro7" then
	local sp_a1_intro7_popped = false
	local sp_a1_intro7_camethrough = false
	local sp_a1_intro7_pickedup = false
	local sp_a1_intro7_pickedupcount = 0
	local sp_a1_intro7_pluggedin = false
	local sp_a1_intro7_turnedaway = false
	local sp_a1_intro7_sayingnotdead = false
	local sp_a1_intro7_saidnotdead = false
end

function sp_a1_intro7_HeyUpHere()
	GladosPlayVcd(466)
end

function sp_a1_intro7_YouFoundIt()
	EntFire("spherebot_train_1_chassis_1","MoveToPathNode","spherebot_train_1_path_11",8.5)
	GladosPlayVcd(467)
end

function sp_a1_intro7_PopPortal()
	if not sp_a1_intro7_popped then
		GladosPlayVcd(469)
	end
end


function sp_a1_intro7_PopPortalNag()
	if not sp_a1_intro7_popped then
		GladosPlayVcd(468)
	end
end

function sp_a1_intro7_ComeThroughNag()
	if not sp_a1_intro7_camethrough then
		GladosPlayVcd(470)
	end
end


function sp_a1_intro7_PoppedAPortal()
	EntFire("portal_detector","Disable","",0.0)
	EntFire("@glados","runscriptcode","sp_a1_intro7_ComeThroughNag()",4.0)
	WheatleyStopNag()
	sp_a1_intro7_popped = true
end

function sp_a1_intro7_JumpToOtherSide()
	WheatleyStopNag()
	sp_a1_intro7_camethrough = true
end

function sp_a1_intro7_ManagementRail()
	--WheatleyStopNag()
	GladosPlayVcd(471)
end

function sp_a1_intro7_OnThree()
	GladosPlayVcd(472)
end

function sp_a1_intro7_Impact()
	GladosPlayVcd(473)
end


function sp_a1_intro7_NotDeadStart()
	sp_a1_intro7_sayingnotdead = true
end

function sp_a1_intro7_NotDeadEnd()
	sp_a1_intro7_sayingnotdead = false
	sp_a1_intro7_saidnotdead = true
	if sp_a1_intro7_pickedup then
		nuke()
		GladosPlayVcd(572)
	end
end


function sp_a1_intro7_PickMeUpNag()
	if not sp_a1_intro7_pickedup then
		GladosPlayVcd(474)
	end
end

function sp_a1_intro7_PickUp()
    sp_a1_intro7_pickedup = true

    if sp_a1_intro7_pickedupcount == 0 then
        sp_a1_intro7_pickedupcount = sp_a1_intro7_pickedupcount + 1

        -- Before the "I'm not dead!" line has started playing
        if not sp_a1_intro7_sayingnotdead and not sp_a1_intro7_saidnotdead then
            nuke()
            GladosPlayVcd(571)
        else
            -- The "I'm not dead!" line finished playing before the pickup happened
            if not (not sp_a1_intro7_saidnotdead and sp_a1_intro7_sayingnotdead) then
                WheatleyStopNag()
                GladosPlayVcd(475)
            end
        end

    elseif sp_a1_intro7_pickedupcount == 1 then
        sp_a1_intro7_pickedupcount = sp_a1_intro7_pickedupcount + 1
        nuke()
        GladosPlayVcd(577)
    end
end

function sp_a1_intro7_PlugMeInNag()
	if not sp_a1_intro7_pluggedin then
		GladosPlayVcd(476)
	end
end

function sp_a1_intro7_NoWatching()
	sp_a1_intro7_pluggedin = true
	WheatleyStopNag()
	GladosPlayVcd(477)
end

function sp_a1_intro7_NoWatchingNag()
	if not sp_a1_intro7_turnedaway then
		GladosPlayVcd(481)
	end
end

function sp_a1_intro7_TurnAroundNow()
	sp_a1_intro7_turnedaway = true
	WheatleyStopNag()
	GladosPlayVcd(478)
end

function sp_a1_intro7_BamSecretPanel()
	sp_a1_intro7_turnedaway = true
	WheatleyStopNag()
	GladosPlayVcd(479)
end

function sp_a1_intro7_GloriousFreedom()
	GladosPlayVcd(480)
end

function sp_a1_intro7_DontLeaveMeNag()
end



----------------------------------------------------------------------------------------------------------------
--sp_a1_wakeup functions
----------------------------------------------------------------------------------------------------------------

if curMapName=="sp_a1_wakeup" then
	local sp_a1_wakeup_gantryexpositionover = false
	local sp_a1_wakeup_gantryexpositioncounter = 0
	local sp_a1_wakeup_humanexpositionover = false
	local sp_a1_wakeup_In_Breaker_Room = false
	local sp_a1_wakeup_Looked_Down = false
end

function sp_a1_wakeup_start_map()
	GladosPlayVcd(482)
end

function sp_a1_wakeup_gantry_exposition_end()
	sp_a1_wakeup_gantryexpositionover = true
end

function sp_a1_wakeup_inside_observation()
    if sp_a1_wakeup_gantryexpositionover then
        sp_a1_wakeup_gantryexpositionover = false

        if sp_a1_wakeup_gantryexpositioncounter == 0 then
            sp_a1_wakeup_gantryexpositioncounter = sp_a1_wakeup_gantryexpositioncounter + 1
            GladosPlayVcd(483)
        elseif sp_a1_wakeup_gantryexpositioncounter == 1 then
            sp_a1_wakeup_gantryexpositioncounter = sp_a1_wakeup_gantryexpositioncounter + 1
            GladosPlayVcd(484)
        elseif sp_a1_wakeup_gantryexpositioncounter == 2 then
            sp_a1_wakeup_gantryexpositioncounter = sp_a1_wakeup_gantryexpositioncounter + 1
            GladosPlayVcd(485)
        elseif sp_a1_wakeup_gantryexpositioncounter == 3 then
            sp_a1_wakeup_gantryexpositioncounter = sp_a1_wakeup_gantryexpositioncounter + 1
            GladosPlayVcd(486)
        end
    end
end

function sp_a1_wakeup_gantry_door_open()    
	GladosPlayVcd(487)
end

function sp_a1_wakeup_there_she_is()
		GladosPlayVcd(488)
end

function sp_a1_wakeup_human_exposition_end()
	sp_a1_wakeup_gantryexpositionend = true
end

function sp_a1_wakeup_down_the_stairs()
		GladosPlayVcd(489)
end

function sp_a1_wakeup_JumpNags()
	GladosPlayVcd(581)
end

function sp_a1_wakeup_Falling()
	nuke()
	GladosPlayVcd(579)
end

function sp_a1_wakeup_Landed()
	GladosPlayVcd(580)
end

function sp_a1_wakeup_come_through_here()
	if sp_a1_wakeup_Looked_Down then
		GladosPlayVcd(586)
	end
end

function sp_a1_wakeup_Do_Not_Look_Down()
		GladosPlayVcd(491)
end

function sp_a1_wakeup_Do_Not_Look_Down_Over()
	sp_a1_wakeup_Looked_Down = true
	EntFire("@ComeThroughHereTrigger","enable","",0.2)
end


function sp_a1_wakeup_This_Is_Breaker_Room()
		GladosPlayVcd(492)
end

function sp_a1_wakeup_Lets_Go_In()
		if not sp_a1_wakeup_In_Breaker_Room then
			GladosPlayVcd(585)
        end
end

function sp_a1_wakeup_Do_Not_Touch()
		sp_a1_wakeup_In_Breaker_Room = true
		GladosPlayVcd(493)
end

function sp_a1_wakeup_Lights_On()
		GladosPlayVcd(494)
end

function sp_a1_wakeup_Oops()
	GladosPlayVcd(542)
end

----------------------------------------------------------------------------------------------------------------
--Wheatley Elevator Scene (currently after sp_a2_column_blocker)
----------------------------------------------------------------------------------------------------------------


function Wheatley_Elevator_Scene_Start()
		GladosPlayVcd(495)
end

function Wheatley_Elevator_Scene_Ow()
		GladosPlayVcd(496)
end

----------------------------------------------------------------------------------------------------------------
--Jailbreak - sp_a2_bts1 & bts2
----------------------------------------------------------------------------------------------------------------

if curMapName == "sp_a2_bts1" then
	sp_a2_bts1_FakeEntered = false
end



function JailbreakGladosSomethingWrong()
	GladosPlayVcd(301)
end

function JailbreakWheatleyHeyLady()
	GladosPlayVcd(497)
end

function JailbreakICanHearYou()
	nuke()
	EntFire( "@sphere", "SetIdleSequence", "sphere_damaged_glance_concerned", 0 )
	GladosPlayVcd(498)
end

function JailbreakWheatleyCloseChamber()
	WheatleyStopNag()	
	GladosPlayVcd(500)
end

function WheatleyKeepMoving()
	--WheatleyStopNag()	
	--GladosPlayVcd(501)
end

function WheatleyGoGoGoNag()
	GladosPlayVcd(502)
end

function JailbreakLastTestIntro()
	WheatleyStopNag()	
	GladosPlayVcd(503)
end

function JailbreakLastChamberMain()
	WheatleyStopNag()	
	GladosPlayVcd(504)
end

function JailbreakLastTestDeer()
	sp_a2_bts1_FakeEntered = true
	WheatleyStopNag()	
	GladosPlayVcd(505)
end

function JailBreakHowStupid()
	if not sp_a2_bts1_FakeEntered then
		WheatleyStopNag()	
		GladosPlayVcd(506)
    end
end

function JailbreakBridgeDisappear()
	WheatleyStopNag()	
	GladosPlayVcd(507)
end

function JailbreakLookOutTurrets()
	WheatleyStopNag()	
	GladosPlayVcd(508)
end

function JailBreak2Trapped()
	WheatleyStopNag()	
	GladosPlayVcd(573)
end

function JailBreak2Gunfire()
	GladosPlayVcd(574)
end

function bts2_wheatley_comeon_prompt()
	GladosPlayVcd(587)
end

function JailBreak2AlmostOut()
	GladosPlayVcd(575)
end

function JailBreak2BringingDown()
	GladosPlayVcd(576)
end

function JailbreakHurryHurry()
	WheatleyStopNag()	
	GladosPlayVcd(509)
end

function JailbreakGetInTheLift()
	WheatleyStopNag()	
	GladosPlayVcd(510)
end

function jailbreak_player_in_exit_elevator()
	WheatleyStopNag()	
	GladosPlayVcd(511)
end

function Jailbreak2ThisWay()
	WheatleyStopNag()	
	GladosPlayVcd(512)
end

function JailbreakGoGo()
	WheatleyStopNag()	
	GladosPlayVcd(513)
end

function JailbreakComeOnComeOn()
	WheatleyStopNag()	
	GladosPlayVcd(514)
end


----------------------------------------------------------------------------------------------------------------
--Turret Factory -- sp_a2_bts4
----------------------------------------------------------------------------------------------------------------

if curMapName=="sp_a2_bts4" then
	sp_a2_bts4_StillThinkingNagStage = 0
	sp_a2_bts4_StillThinkingNagOK = false
	sp_a2_bts4_StillThinkingNagIdx = 0
	sp_a2_bts4_StillThinkingNagTime = 0
	sp_a2_bts4_MentionedSwap = false
	sp_a2_bts4_At_Window = false
	sp_a2_bts4_At_Big_Potato = false
	sp_a2_bts4_At_Volcano = false
	sp_a2_bts4_Intro_Talking = false
	sp_a2_bts4_Science_Fair_Busy = false
	sp_a2_bts4_Did_Big_Potato = false
	sp_a2_bts4_Did_Volcano = 0
	
end	


function FactoryWheatleyHey()
	GladosPlayVcd(515)
end

function FactoryFollowMe()
	GladosPlayVcd(516)
end

function FactoryAlmostThere()
	GladosPlayVcd(518)
end


function FactoryTahDah()
	GladosPlayVcd(517)
end

function FactoryScannerIntro()
	sp_a2_bts4_At_Window = true
	if not sp_a2_bts4_Intro_Talking then
		GladosPlayVcd(519)
	end
end

function FactoryScannerSpeech()
	GladosPlayVcd(519)
end

function FactoryCheckAtWindowEnd()
	sp_a2_bts4_Intro_Talking = false
	if sp_a2_bts4_At_Window then
		FactoryScannerSpeech()
	end
end

function FactoryCheckAtWindowStart()
	sp_a2_bts4_Intro_Talking = true
	if sp_a2_bts4_At_Window then
		FactoryScannerSpeech()
	end
end
--[[

function FactoryControlDoorHackIntro()
{
	GladosPlayVcd(520)
}

function FactoryControlRoomHackSuccess()
{
	WheatleyStopNag()	
	GladosPlayVcd(521)
}

function FactoryFirstTurretTaken()
{
	WheatleyStopNag()	
	GladosPlayVcd(522)
}

function FactoryFirstTurretPulled()
{
	--WheatleyStopNag()	
	--GladosPlayVcd(522)
}


function FactoryEnableThinkingNag()
{
	printlDBG("%%%%%%%%%%%%%%%%ENABLE STILL THINKING NAG")
	sp_a2_bts4_StillThinkingNagOK = true
}

function FactoryDisableThinkingNag()
{
	printlDBG("%%%%%%%%%%%%%%%%DISABLE STILL THINKING NAG")
	sp_a2_bts4_StillThinkingNagOK = false
}

function FactoryStillThinkingNag()
{
	printlDBG("%%%%%%%%%%%%%%%%STILL THINKING NAG")
	switch (sp_a2_bts4_StillThinkingNagStage)
	{
		case 0:
			if (!sp_a2_bts4_StillThinkingNagOK)
			{
				return
			}
			if (!(characterCurscene("wheatley")==nil))
			{
				sp_a2_bts4_StillThinkingNagTime = Time()
				return
			}	
			if (Time()-sp_a2_bts4_StillThinkingNagTime > 5 && RandomInt(1,100) > 50)
			{
				sp_a2_bts4_StillThinkingNagIdx+=1
				sp_a2_bts4_StillThinkingNagTime=Time()
				switch (sp_a2_bts4_StillThinkingNagIdx)
				{
					case 1:
						GladosPlayVcd(523)
						break
					case 2:
						GladosPlayVcd(524)
						break
					case 3:
						GladosPlayVcd(525)
						break
					case 4:
						GladosPlayVcd(526)
						break
					case 5:
						GladosPlayVcd(527)
						break
					case 6:
						GladosPlayVcd(528)
						break
					case 7:
						sp_a2_bts4_MentionedSwap = true
						GladosPlayVcd(529)
						break
					case 8:
						sp_a2_bts4_MentionedSwap = true
						GladosPlayVcd(530)
						break
					default:
						sp_a2_bts4_MentionedSwap = true
						GladosPlayVcd(531)
						break
				}
			}
			break
		case 1:
	}
}	


function FactoryWhereAreYouGoing()
{
	if (!sp_a2_bts4_MentionedSwap)
	{
		GladosPlayVcd(532)
	}
}

function FactoryWhereAreYouGoingTwo()
{
	if (!sp_a2_bts4_MentionedSwap)
	{
		GladosPlayVcd(533)
	}	
}


function FactoryBroughtBackDefectiveTurret()
{
	printlDBG("$$$$$$$$$$$$$CRAP TURRET TRIGGER")
	sp_a2_bts4_StillThinkingNagStage = 2
	if (sp_a2_bts4_MentionedSwap)
	{
		GladosPlayVcd(535)
	}
	else
	{
		GladosPlayVcd(534)
	}
}

function FactoryWheatleyShoutout()
{
	if (!sp_a2_bts4_MentionedSwap)
	{
		GladosPlayVcd(541)
	}
}

function FactoryEnterScannerRoomWithTurret()
{
	if (!sp_a2_bts4_MentionedSwap)
	{
		GladosPlayVcd(540)
	}
}

function FactorySuccess()
{
	sp_a2_bts4_StillThinkingNagStage = 2
	if (sp_a2_bts4_MentionedSwap)
	{
		GladosPlayVcd(539)
	}
	else
	{
		GladosPlayVcd(538)
	}
}


function ScienceFairBusy()
{
	sp_a2_bts4_Science_Fair_Busy = true
}

function ScienceFairNotBusy()
{
	sp_a2_bts4_Science_Fair_Busy = false
	if (sp_a2_bts4_At_Volcano)
	{
		PlayerNearScienceFairVolcano()
		return
	}
	if (sp_a2_bts4_At_Big_Potato)
	{
		PlayerLookingAtScienceFairPotato()
		return
	}
}


function PlayerNearScienceFairVolcano()
{
	sp_a2_bts4_At_Volcano = true
	if (!sp_a2_bts4_Science_Fair_Busy)
	{
		switch (sp_a2_bts4_Did_Volcano)
		{
			case 0:
				sp_a2_bts4_Did_Volcano = 1
				GladosPlayVcd(583)
				break
			case 1:
				sp_a2_bts4_Did_Volcano = 2
				GladosPlayVcd(584)
				break
		}		
	}	
}	

function PlayerLeavingScienceFairVolcano()
{
	sp_a2_bts4_At_Volcano = false
}


function PlayerLookingAtScienceFairPotato() -- fires once player looks at potato plant
{
	sp_a2_bts4_At_Big_Potato = true
	if (!sp_a2_bts4_Science_Fair_Busy)
	{
		if (!sp_a2_bts4_Did_Big_Potato)
		{
			sp_a2_bts4_Did_Big_Potato = true
			GladosPlayVcd(582)
		}	
	}	
}


function PlayerNotLookingAtScienceFairPotato() -- fires if player looks away from plant after looking at it
{
		sp_a2_bts4_At_Big_Potato = false
}


----------------------------------------------------------------------------------------------------------------
-- BTS4 conveyor turret functions
----------------------------------------------------------------------------------------------------------------
]]
-- ========================================================
-- Called when the player gets near the turret for the first time
-- ========================================================

if curMapName=="sp_a2_bts4" then
	sp_a2_bts4_redemption_turret_held = false
	sp_a2_bts4_redemption_turret_babble_index = 0
	sp_a2_bts4_redemption_turret_babbling = false
end


function SabotageFactoryRecycledTurretNoticesPlayer()
	GladosPlayVcd(439, nil, "conveyor_turret_body")
end


-- ========================================================
-- SP_A2_BTS4 ACHIEVEMENT - ACH.SAVE_REDEMPTION_TURRET
-- ========================================================
function bts4_redemption_line_turret_achievement()
	-- award achievement after turret is done speaking
	EntFire("achievement_redemption_line", "fireevent", 0, 0 )
end

-- ========================================================
-- Called every time the turret is picked up
-- ========================================================
function bts4_redemption_line_turret_pickup()
	sp_a2_bts4_redemption_turret_held = true
	if not sp_a2_bts4_redemption_turret_babbling then
		GladosPlayVcd(614, nil, "conveyor_turret_body")
	end
end

-- ========================================================
-- Called every time the turret is dropped
-- NOTE: when turret gets fizzled it is also dropped
-- so this function will get called
-- ========================================================
function bts4_redemption_line_turret_drop()
	sp_a2_bts4_redemption_turret_held = false
end

function bts4_redemption_line_turret_babble_start()
	sp_a2_bts4_redemption_turret_babbling = true
end

function bts4_redemption_line_turret_babble_end()
	local dly = math.random(2,5)
	sp_a2_bts4_redemption_turret_babbling = false
	if sp_a2_bts4_redemption_turret_held then
		EntFire("@glados","runscriptcode","bts4_redemption_line_turret_babble()",dly)
	end
end


function bts4_redemption_line_turret_babble()
	if not sp_a2_bts4_redemption_turret_babbling then
		if sp_a2_bts4_redemption_turret_held then
			if sp_a2_bts4_redemption_turret_babble_index < 8 then
				sp_a2_bts4_redemption_turret_babble_index = sp_a2_bts4_redemption_turret_babble_index + 1
				GladosPlayVcd(614+sp_a2_bts4_redemption_turret_babble_index, nil, "conveyor_turret_body")
			end
		end
	end
end


-- ========================================================
-- Called if turret is not saved and goes through conveyor exit
-- ========================================================
function bts4_redemption_line_turret_not_saved()
	GladosCharacterStopScene("conveyor_turret_body")
	GladosPlayVcd(613, nil, "conveyor_turret_body")
end

-- ========================================================
-- Called if player and turret are approaching the fizzler
-- NOTE: if the player leaves and comes back this could be triggered
-- again!
-- ========================================================
function bts4_redemption_line_fizzler_approach()
end

-- ========================================================
-- Called if turret gets fizzled
-- ========================================================
function bts4_redemption_line_turret_fizzled()	
	GladosCharacterStopScene("conveyor_turret_body")
	GladosPlayVcd(613, nil, "conveyor_turret_body")
end

-- ========================================================
-- Called when player gets into dummy shoot area
-- ========================================================
function bts4_redemption_line_turret_safe()
end


----------------------------------------------------------------------------------------------------------------
--Turret Factory -- sp_a2_intro - incinerator
----------------------------------------------------------------------------------------------------------------

function sp_a2_intro_SecondSpeech()
	if characterCurscene("glados") == nil then
		GladosPlayVcd(206)
	else
		GladosPlayVcd(543)
    end
end

function sp_a2_intro_ClearArms()
	if characterCurscene("glados") == nil then
		GladosPlayVcd(208)
	else
		GladosPlayVcd(544)
    end
end


----------------------------------------------------------------------------------------------------------------
--sp_a1_intro1
----------------------------------------------------------------------------------------------------------------

if curMapName=="sp_a1_intro1" then
	sp_a1_intro1_fizzler_triggered = false
	sp_a1_intro1_fizzler_said = false
	sp_a1_intro1_fizzler_passed = false
end

function sp_a1_intro1_fizzler_intro()
	sp_a1_intro1_fizzler_triggered = true
	if characterCurscene("glados") == nil then
		sp_a1_intro1_fizzler_said = true
		GladosPlayVcd(553)
    end
end

function sp_a1_intro1_fizzler_passed()
	if not sp_a1_intro1_fizzler_said then
		sp_a1_intro1_fizzler_passed = true
		if characterCurscene("glados") == nil then
			sp_a1_intro1_fizzler_said = true
			GladosPlayVcd(630)
        end
    end
end

function sp_a1_intro1_fizzler_test()
	if sp_a1_intro1_fizzler_triggered and not sp_a1_intro1_fizzler_said then
		sp_a1_intro1_fizzler_said = true
		if sp_a1_intro1_fizzler_passed then
			GladosPlayVcd(630)
		else
			GladosPlayVcd(553)
        end
	end
end

----------------------------------------------------------------------------------------------------------------
--sp_a1_intro3
----------------------------------------------------------------------------------------------------------------

--Triggers when you drop into the "Mind the Gap" puzzle
function sp_a1_intro3_turret_live_fire()
	GladosPlayVcd(623)
end


----------------------------------------------------------------------------------------------------------------
--sp_a1_intro6
----------------------------------------------------------------------------------------------------------------

function sp_a1_intro6_PuzzleOneCompleted()
	printlDBG("Insert puzzle 1 completed dialog here.")
end



----------------------------------------------------------------------------------------------------------------
--sp_a2_fizzler_training
----------------------------------------------------------------------------------------------------------------
function sp_a2_fizzler_training_Have_To_Go()
	GladosPlayVcd(546)
end

----------------------------------------------------------------------------------------------------------------
--sp_a4_turret_tbeam functions
----------------------------------------------------------------------------------------------------------------

function Finale02_turret_tbeam_abort1()
	GladosPlayVcd(556)
end

function Finale02_turret_tbeam_2()
	GladosPlayVcd(557)
end

function Finale02_turret_tbeam_abort2()
	GladosPlayVcd(558)
end

function Finale02_turret_tbeam_3()
	GladosPlayVcd(559)
end

function Finale02_turret_tbeam_abort3()
	GladosPlayVcd(560)
end

--stub function from co-op
function BotDeath(arg,arg2)
end

--sp_a1_intro6_first half of chamber
function MidpointPuzzleCompleted()
	GladosPlayVcd(626)
end



----------------------------------------------------------------------------------------------------------------
-- Control Potatos light
----------------------------------------------------------------------------------------------------------------

function PotatosTurnOff()
	GetPlayer().TurnOffPotatos();
end

function PotatosTurnOn()
	GetPlayer().TurnOnPotatos();
end
