print("[P2] glados.lua loaded")
--ispaused()
--IsPlayingBack()
--EstimateLength()

-- debug stuff
local debug = true       -- Set true to enable debug block during think function
local debugInterval = 10.00

local lastthink = CurTime()
local startBlock = 0

-- Queue of scenes started with GladosPlayVcd()
local scenequeue = {}
local firedfromqueue = false

-- Map Name
local curMapName = game.GetMap()

-- PitchShifting stuff
local pitchShifting = false
local pitchShiftLastThink = CurTime()
local pitchShiftInterval = 1.0
local pitchShiftValue = 1.0
local pitchOverride = nil

-- State Flags
local stateSlowFieldTraining = false

-- jailbreak specific stuff
if curMapName == "sp_sabotage_jailbreak_01" or curMapName == "sp_sabotage_jailbreak" or curMapName == "sp_a2_bts1" then
    jailbreakpos = 0
end

-- sp_catapult_fling_sphere_peek specific stuff
if curMapName == "sp_a2_sphere_peek" then
    peekctr = 0
end


--Dings
local sceneDingOn  = CreateSceneEntity("scenes/npc/glados_manual/ding_on.vcd")
local sceneDingOff = CreateSceneEntity("scenes/npc/glados_manual/ding_off.vcd")

//Include the autogenerated scene table
include("portal2/vscript/choreo/glados_scenetable_include.lua")

//Include the manual scene table
include("portal2/vscript/choreo/glados_scenetable_include_manual.lua")

function printldebug(arg)
	if debug then
		print(arg)
	end
end


-- -------------------------------------------------------------------
-- Precache sounds we will emit
-- Define like this: self.PrecacheSoundScript( "Your.SoundName" )
--
-- Then you call the sound like so:
-- self.EmitSound("Your.SoundName")
-- -------------------------------------------------------------------
function Precache()          
	if curMapName=="sp_a4_tb_trust_drop" then
		self.PrecacheSoundScript( "World.WheatleyZap" )
	end
	if curMapName=="sp_a1_wakeup" then
		self.PrecacheSoundScript( "World.HackBuzzer" )
	end
	if curMapName=="sp_a3_speed_ramp" then
		self.PrecacheSoundScript( "World.WheatleyZap" )
		self.PrecacheSoundScript( "World.GladosPotatoZap" )
	end
	if curMapName=="sp_a3_transition01" then
		self.PrecacheSoundScript( "World.GladosPotatoZap" )
end

end

--function testemito()
--{
--	self.EmitSound("World.Electrocution")
--}




-- OnPostSpawn - this is all the initial setup stuff
function OnPostSpawn()
		local i = 0
		--assign a unique id to each scene entity (uses SetTeam because that's the only thing available)
		for _, val in pairs(SceneTable) do
			i = i + 1
			val.vcd:ValidateScriptScope()
			val.vcd:SetTeam(i)
			val.index = i
		end	
		--Initialize the deferred scene queue
		QueueInitialize()
		PuzzlePreStart()
		
		--Map specific Spawn stuff
		if curMapName == "sp_a1_wakeup" then
   			EntFire("@glados", "runscriptcode", "sp_a1_wakeup_start_map()", 1.0)
		end
end



//Passed the unique team id associated with a scene entity defined in SceneTable, this function returns the correct SceneTable index for that entry
//ex: SceneTableInst = SceneTable[findIndex(team)]
function findIndex(team)
		local idx, val
		for idx, val in pairs(SceneTable) do
			if val.index == team then
				return idx
			end
		end
		return nil
end

//Passed the unique team id associated with a scene entity defined in SceneTable, this function returns the scene instance that originally fired it.
//Unfortunately, if multiple scene instances fire the same vcd, this isn't reliable. Hopefully we can either a) fix that 
//or b) not have multiple scene instances use the same vcd (which is currently the case as of 07/19/2010 - efw)
function FindSceneInstanceByTeam(team)
	local idx, val
	local idx2, val2
	local inst = null
	for idx, val in ipairs(scenequeue) do
		for idx2, val2 in ipairs(val.waitFiredVcds) do
			if val2 == team then
				inst = val
				break
			end
		end
		if inst ~= null then
			break
		end
	end
	return inst
end


function SceneCanceled()
	printldebug("========SCENE CANCELLED - CALLING ENTITY: "+findIndex(owninginstance.GetTeam()))
end

//If a vcd is tagged to "exit early" (by setting postdelay < 0), this event fires rather than PlayNextScene() when the vcd finishes.
//SkipOnCompletion() has all the functionality of PlayNextScene(), except it doesn't actually play the next scene, because the next scene presumably
//already started playing when the vcd exited early.
//SkipOnCompletion does, however, evaluate the vcd's SceneTable entry to see if any EntFires need to happen.
function SkipOnCompletion()
    printldebug("========SKIPONCOMPLETION CALLING ENTITY: " .. findIndex(owninginstance:GetTeam()) .. " : TIME " .. CurTime())

    local team = owninginstance:GetTeam()
    local inst = FindSceneInstanceByTeam(team)

    if inst ~= nil then
        inst:deleteFiredVcd(team)
        inst.waitVcdCurrent = findIndex(team)

        -- Are there any EntFires associated with this vcd?
        if inst.waitVcdCurrent ~= nil and SceneTable[inst.waitVcdCurrent].fires then
            for _, val in ipairs(SceneTable[inst.waitVcdCurrent].fires) do
                if not val.fireatstart then
                    printldebug(">>>>>>ENT FIRE AT (SKIPCOMPLETION) END: " .. val.entity .. ":" .. val.input)
                    EntFire(val.entity, val.input, val.parameter, val.delay)
                end
            end
        end
    end
end


function PlayNextScene()
    local team = owninginstance:GetTeam()
    local inst = FindSceneInstanceByTeam(team)

    if inst ~= nil then
        printldebug("========PLAYNEXTSCENE CALLING ENTITY: " .. findIndex(owninginstance:GetTeam()) .. " : TIME " .. CurTime())
        inst:deleteFiredVcd(team)
        inst.waitVcdCurrent = findIndex(team)
        PlayNextSceneInternal(inst)
    else
        printldebug("========PLAYNEXTSCENE CALLING ENTITY NO LONGER EXISTS: CHECKING QUEUE...")
        QueueCheck()
    end
end



function PlayNextSceneInternal(inst)
    -- inst = just completed scene
    local i = 0
    local tmp = 0


    -- Are there any "fire at the end" triggers associated with the just completed?
    if inst and inst.waitVcdCurrent ~= nil then
        if SceneTable[inst.waitVcdCurrent].fires then
            for idx, val in ipairs(SceneTable[inst.waitVcdCurrent].fires) do
                if not val.fireatstart then
                    printldebug(">>>>>>ENT FIRE AT END: " .. val.entity .. ":" .. val.input)
                    EntFire(val.entity, val.input, val.parameter, val.delay)
                end
            end
        end
    end

    -- If the vcd that's ending is part of a nag cycle, check to see if there are queued scenes.
    if inst and inst.isNag then
        if QueueLen(inst.currentCharacter) > 0 then
            printldebug("========ABANDONING NAG CYCLE TO PLAY QUEUED SCENE")
            scenequeue_DeleteScene(inst.index)
            QueueCheck()
            return
        end
    end

    -- Is there another vcd in the scene chain?
    if inst and inst.waitNext ~= nil then
        printldebug("=====There is a next scene: " .. tostring(inst.waitNext))
        if inst.waitLength == nil then
            i = i + 1
            printldebug("===================Ready to play:" .. i)
            GladosPlayVcd(inst)
        else
            inst.waitStartTime = CurTime()
            inst.waiting = 1
        end
    else
        printldebug("=====No next scene!")
        -- Remove the instance from the scene list
        scenequeue_DeleteScene(inst.index)
        -- Check for queued scenes
        if QueueCheck() then return end
        -- Ding if nothing is queued and the previous scene requires it
        if not inst.waitNoDingOff then
            EntFireByHandle(sceneDingOff, "Start", "", 0.1, nil, nil)
        end
    end
end


//Think function
function GladosThink()
    -- Put debug stuff here!
    if debug then
        if (CurTime() - lastthink > debugInterval) then
            print("===== GladosThink -> " .. tostring(lastthink))
            lastthink = CurTime()
            QueueDebug()
        end
    end

    -- Are we PitchShifting?
    if pitchShifting then
        if (CurTime() - pitchShiftLastThink > pitchShiftInterval) then
            local curscene = self:GetCurrentScene()
            if curscene ~= nil then
                local shiftAmount = math.Rand(-0.10, 0.10)
                if shiftAmount < 0 then
                    shiftAmount = shiftAmount * 1.5
                end
                pitchShiftValue = pitchShiftValue + shiftAmount
                if pitchShiftValue <= 0.0 or pitchShiftValue >= 1.7 then
                    pitchShiftValue = pitchShiftValue - (shiftAmount * 2)
                end
                EntFireByHandle(curscene, "PitchShift", tostring(pitchShiftValue), 0, nil, nil)
                pitchShiftInterval = math.Rand(0.1, 0.2)
            end
            pitchShiftLastThink = CurTime()
        end
    end

    -- Scan the list of currently playing scenes
    for idx, val in ipairs(scenequeue) do
        -- Check if the current VCD is scheduled to exit early
        if val.waitPreDelayed then
            if CurTime() >= val.waitDelayingUntil then
                print("******* LAUNCHING PREDELAYED SCENE")
                GladosPlayVcd(val)
            end
        end

        if val.waitExitingEarly then
            if CurTime() - val.waitExitingEarlyStartTime >= val.waitExitingEarlyThreshold then
                val.waitExitingEarly = false
                local curscene = characterCurscene(val.currentCharacter)
                if curscene ~= nil then
                    curscene:ValidateScriptScope()
                    curscene:GetScriptScope().SkipOnCompletion = SkipOnCompletion -- bindenv not needed in GLua
                    curscene:DisconnectOutput("OnCompletion", "PlayNextScene")
                    curscene:DisconnectOutput("OnCompletion", "SkipOnCompletion")
                    curscene:ConnectOutput("OnCompletion", "SkipOnCompletion")
                    local team = curscene:GetTeam()
                    val.waitVcdCurrent = findIndex(team)
                end
                print("==== Scene " .. tostring(val.index) .. " EXITING EARLY")
                PlayNextSceneInternal(val)
                return
            end
        end
    end

    -- Check the deferred scene queue
    local tmp = QueueThink()
    if tmp ~= nil then
        print("=========== FORCING QUEUED SCENE: " .. tostring(tmp))
        GladosPlayVcd(tmp, true)
        return
    end

    -- Check if we are waiting to play another VCD
    for idx, val in ipairs(scenequeue) do
        if val.waiting == 1 then
            if CurTime() - val.waitStartTime >= val.waitLength then
                val.waiting = 0
                GladosPlayVcd(val)
            end
        end
    end
end

--functions used by GPV
function is_scene_instance(obj)
    return type(obj) == "table" and obj.waitNext ~= nil
end

concommand.Add("gladosplayvcd", function(ply, cmd, args, argStr)
    if ply:IsAdmin() then
        local param = args[1]
        GladosPlayVcd(tonumber(param))
    else
        print("You need permission to run this command")
    end
end, nil, "Runs GladosPlayVcd with the provided scene number.")

--GPV itself
function GladosPlayVcd(arg, IgnoreQueue, caller)
    printldebug("=========GladosPlayVcd Called!=========" .. tostring(arg))

    local inst
    local fromqueue = firedfromqueue
    firedfromqueue = false
    local dingon = false

    -- Determine if arg is an existing scene instance
    if is_scene_instance(arg) then
        inst = arg

        if inst.waitPreDelayed then
            arg = inst.waitPreDelayedEntry
        else
            arg = inst.waitNext
        end

    else
        -- Starting new scene from SceneTable
        local sceneStart = 0

        if type(arg) == "number" then
            if arg == 407 or arg == 43 then return end
            sceneStart = arg
            printldebug("GladosPlayVcd (map integer): " .. tostring(arg))
            arg = SceneTableLookup[arg]
        end

        if not arg or SceneTable[arg] == nil then
            printldebug("GladosPlayVcd: invalid scene arg: " .. tostring(arg))
            return
        end

        -- Skip if busy
        if SceneTable[arg].skipifbusy and characterCurscene(SceneTable[arg].char) ~= nil then
            return
        end

        -- Queue handling
        if SceneTable[arg].queue and IgnoreQueue == nil then
            local queueChar = SceneTable[arg].queuecharacter or SceneTable[arg].char
            if characterCurscene(queueChar) ~= nil then
                QueueAdd(arg)
                return
            end
        end

        -- Add to scenequeue
        if scenequeue_AddScene(arg, SceneTable[arg].char) == nil then return end
        inst = scenequeue[arg]
        inst.waitSceneStart = sceneStart

        if SceneTable[arg].idle then
            nags_init(inst, arg)
        end

        -- New dialog block
        dingon = true
        pitchShifting = false
        inst.waitNoDingOff = SceneTable[arg].noDingOff or false
        inst.waitNoDingOn  = SceneTable[arg].noDingOn or false
    end

    -- Pre-delay
    if not inst.waitPreDelayed then
        local preDelay = EvaluateTimeKey("predelay", SceneTable[arg])
        if fromqueue and SceneTable[arg].queuepredelay then
            preDelay = EvaluateTimeKey("queuepredelay", SceneTable[arg])
        end

        if preDelay > 0.0 then
            inst.waitPreDelayed = true
            inst.waitDelayingUntil = CurTime() + preDelay
            inst.waitPreDelayedEntry = arg
            printldebug("======= " .. tostring(arg) .. " PREDELAYED FOR " .. tostring(preDelay) .. " SECONDS")
            return
        end
    else
        inst.waitPreDelayed = false
        inst.waitPreDelayedEntry = nil
    end

    -- Nag handling
    if inst.isNag and not inst.naginchain then
        arg = nags_fetch(inst)
    end

    if arg == nil then
        scenequeue_DeleteScene(inst.index)
        return
    end

    local ltalkover = SceneTable[arg].talkover or false
    if not ltalkover then
        GladosAllCharactersStopScene()
    else
        GladosCharacterStopScene(SceneTable[arg].char)
    end

    -- Play initial ding if needed
    if dingon and not inst.waitNoDingOn then
        SafeEntFire(sceneDingOn, "Start", "", 0.0)
        print("[P2] SafeEntFire #1 ran")
    end

    -- Start VCD
    printldebug("===================Playing: " .. tostring(arg))
    inst.currentCharacter = SceneTable[arg].char
    local vcdEnt = SceneTable[arg].vcd

    -- Set target1
    if caller then
        local name = type(caller) == "string" and caller or (IsValid(caller) and caller:GetName())
        if name then SafeEntFire(vcdEnt, "SetTarget1", name, 0) print("[P2] SafeEntFire #2 ran") end
    end
    if SceneTable[arg].settarget1 then
        SafeEntFire(vcdEnt, "SetTarget1", SceneTable[arg].settarget1, 0)
        print("[P2] SafeEntFire #3 ran")
    end

    -- Track fired VCDs
    if type(inst.addFiredVcd) == "function" then
        pcall(function() inst:addFiredVcd(SceneTable[arg].index) end)
    else
        inst.waitFiredVcds = inst.waitFiredVcds or {}
        table.insert(inst.waitFiredVcds, SceneTable[arg].index)
    end

    -- Start VCD with slight delay if ding was played
    local startDelay = (dingon and not inst.waitNoDingOn) and 0.18 or 0.0
    SafeEntFire(vcdEnt, "Start", "", startDelay)
    print("[P2] SafeEntFire #4 ran")

    -- Fire entities at start
    if SceneTable[arg].fires then
        for _, val in ipairs(SceneTable[arg].fires) do
            if val.fireatstart then
                printldebug(">>>>>>ENT FIRE AT START: " .. tostring(val.entity) .. ":" .. tostring(val.input))
                SafeEntFire(val.entity, val.input, val.parameter, val.delay)
                print("[P2] SafeEntFire #5 ran")
            end
        end
    end

    -- Special cases (pitching)
    if SceneTable[arg].special then
        local s = SceneTable[arg].special
        if s == 1 then
            pitchShifting = true
        elseif s == 2 then
            if pitchOverride == nil then SafeEntFire(vcdEnt, "PitchShift", "2.5", 0) end
        elseif s == 3 then
            SafeEntFire(vcdEnt, "PitchShift", "0.9", 0)
            print("[P2] SafeEntFire #6 ran")
        end
    end

    if pitchOverride ~= nil then
        SafeEntFire(vcdEnt, "PitchShift", tostring(pitchOverride), 0)
        print("[P2] SafeEntFire #7 ran")
    end

    -- Setup     line
    if SceneTable[arg].next or inst.isNag then
        local pdelay = EvaluateTimeKey("postdelay", SceneTable[arg])
        if inst.isNag then
            pdelay = math.Rand(inst.nagminsecs, inst.nagmaxsecs)
        end

        if pdelay < 0 then
            inst.waitExitingEarly = true
            inst.waitLength = nil
            inst.waitExitingEarlyStartTime = CurTime()
            inst.waitExitingEarlyThreshold = -pdelay
        else
            inst.waitExitingEarly = false
        end

        if inst.isNag then
            inst.waitNext = SceneTable[arg].next or arg
            inst.naginchain = SceneTable[arg].next ~= nil
        else
            inst.waitNext = SceneTable[arg].next
        end

        inst.waitLength = pdelay
    else
        inst.waitNext = nil
        printldebug("===================SCENE END")
    end
end


function EvaluateTimeKey(keyname, keytable)
    local ret = 0.0 -- default return if key is missing

    if keytable and keytable[keyname] ~= nil then
        local val = keytable[keyname]

        if istable(val) then
            if #val ~= 2 then
                printldebug("!!!!!!!!!!!!EVALUATE TIME KEY ERROR: " .. tostring(keyname) .. " is an array with a length != 2")
                return 0.0
            end
            ret = math.Rand(tonumber(val[1]) or 0, tonumber(val[2]) or 0)
        else
            ret = tonumber(val) or 0.0
        end
    end

    printldebug(">>>>>>>>>EVALUATE TIME KEY: " .. tostring(keyname) .. " : " .. tostring(ret))
    return ret
end


function GladosToggleDebug(arg)
    debug = not debug
    if debug then
        print("======================GLaDOS debug ON")
    else
        print("======================GLaDOS debug OFF")
    end

    if arg ~= nil then
        debugInterval = arg
    end
end

function GladosSetPitch(arg)
	pitchOverride = arg
	local curscene = self.GetCurrentScene()
	if curscene ~= nil then
		EntFireByHandle( curscene, "PitchShift", pitchOverride.tostring(), 0, nil, nil )
	end
end


//Nukes Everything. Delete all currently playing & queued scenes.
function nuke()
	scenequeue = {}
	Queue = {}
	GladosAllCharactersStopScene()
	StopAllCaveSpeakers()
	
end

//Checks each cave speaker actor to see if it's playing a vcd and stops it if it is.
function StopAllCaveSpeakers()
    --[[
    local caveactors = {
        "@cave_exit_lift",
        "cave_a3_03_dummy",
        "cave_a3_03_dummy2",
        "cave_a3_03_dummy3",
        "cave_a3_03_exit",
        "cave_a3_03_lift_shaft",
        "cave_a3_03_waiting_room",
        "cave_a3_jump_intro_entrance",
        "cave_a3_jump_intro_interchamber",
        "cave_a3_jump_intro_second_chamber",
        "cave_a3_transition01_dummy",
        "cave_a3_transition01_dummy2",
        "cave_a3_transition01_dummy3",
        "cave_bomb_flings_chamber",
        "cave_bomb_flings_entrance",
        "cave_crazy_box_2nd_chamber",
        "cave_crazy_box_dummy_chamber",
        "cave_crazy_box_entrance",
        "cave_portal_intro_entrance",
        "cave_portal_intro_exit",
        "cave_portal_intro_office",
        "cave_portal_intro_whitepaint",
        "cave_speed_flings_entrance",
        "cave_speed_ramp_entrance",
        "cave_speed_ramp_inter_chamber",
        "cave_transition01_dummy_exit",
        "cave_transition01_welcome"
    }

    for _, name in ipairs(caveactors) do
        local ent = nil
        ent = ents.FindByName(ent, name)
        if ent ~= nil then
            local sc = ent.GetCurrentScene and ent:GetCurrentScene() or nil
            if sc ~= nil then
                EntFireByHandle(sc, "Cancel", "", 0, nil, nil)
            end
        end
    end
    ]]
end


//Stops a scene for all characters
function GladosAllCharactersStopScene()
	GladosCharacterStopScene("glados")
	GladosCharacterStopScene("wheatley")
	GladosCharacterStopScene("cave_body")
	GladosCharacterStopScene("core01")
	GladosCharacterStopScene("core02")
	GladosCharacterStopScene("core03")
end

function characterCurscene(arg)
    local ret = nil
    local ent = nil

    if arg == "bossannouncer" then
        ent = ents.FindByName("@actor_announcer")
    elseif arg == "announcerglados" or arg == "glados" or arg == "@glados" then
        ent = ents.FindByName("@glados")
    elseif arg == "cave" or arg == "@cave" then
        ent = ents.FindByName("@cave")
    elseif arg == "wheatley" or arg == "sphere" or arg == "@sphere" then
        ent = ents.FindByName("@sphere")
    elseif arg == "core01" or arg == "@core01" then
        ent = ents.FindByName("@core01")
    elseif arg == "core02" or arg == "@core02" then
        ent = ents.FindByName("@core02")
    elseif arg == "core03" or arg == "@core03" then
        ent = ents.FindByName("@core03")
    elseif arg == "cave_body" or arg == "cavebody" then
        ent = ents.FindByName("@cave_body")
    elseif arg == "conveyor_turret" then
        ent = ents.FindByName("conveyor_turret_body")
    end

    if ent ~= nil then
        printldebug("&&&&&&FOUND ENTITY: " .. arg)
        ret = ent.GetCurrentScene and ent:GetCurrentScene() or nil
    end

    return ret
end

//Stops a scene for a particular character
function GladosCharacterStopScene(arg)
    local ent = nil
    local curscene = characterCurscene(arg)
    
    if curscene ~= nil then
        printldebug("&&&&&&STOP SCENE: " .. arg .. " FOUND SCENE TO DELETE!!!!!!!!!")
        EntFireByHandle(curscene, "Cancel", "", 0, nil, nil)
    else    
        printldebug("&&&&&&STOP SCENE: NO SCENE TO DELETE FOR " .. arg)
    end
end

-- Turns off current Glados speech
function GladosStopTalking(ent)
    local curscene = ent and ent.GetCurrentScene and ent:GetCurrentScene() or nil
    pitchOverride = nil
    waitNext = nil
    waitLength = nil
    if curscene ~= nil then
        EntFireByHandle(curscene, "Cancel", "", 0, nil, nil)
    end
end

-- Turns off current Glados speech if the scene # passed as arg is currently playing
function GladosStopScene(ent, arg)
    if waitSceneStart == arg then
        local curscene = ent and ent.GetCurrentScene and ent:GetCurrentScene() or nil
        pitchOverride = nil
        waiting = 0
        waitNext = nil
        waitLength = nil
        if curscene ~= nil then
            EntFireByHandle(curscene, "Cancel", "", 0, nil, nil)
        end
    end
end

-- Slowfield functions
function GladosEndSlowFieldTraining(ent)
    stateSlowFieldTraining = false
    GladosStopTalking(ent)
end

function GladosStartSlowFieldTraining()
    stateSlowFieldTraining = true
    GladosPlayVcd(40)
end

function GladosSlowFieldOn()
    if stateSlowFieldTraining then
        GladosPlayVcd(41)
    end
end

function GladosSlowFieldOff()
    if stateSlowFieldTraining then
        GladosPlayVcd(40)
    end
end
-- End of Slowfield functions

-- Special Chamber Processing
function GladosRelaxationVaultPowerUp()
    EntFire("open_portal_relay", "Trigger", "", 0.0)
end


//----------------------------------------------------------------------------------------------------------------
// Automated dialog lookup
//----------------------------------------------------------------------------------------------------------------

function MapNameConversion(orgname)
    if MapBspConversion[orgname] ~= nil then
        return MapBspConversion[orgname]
    else
        return orgname
    end
end


GladosDialog =
{
	{ map = "sp_a1_intro2", prestart = "PreHub01PortalCarouselEntry01", completed = "PreHub01PortalCarouselSuccess01" },
	{ map = "sp_a1_intro3", prestart = "sp_intro_03Start01", completed = "sp_intro_03MindTheGapFinish01" },
	{ map = "sp_a1_intro4", start = "PreHub01BoxDropperEntry01", completed = "sp_a1_intro4End01" },
	--{ map = "sp_a1_intro5", start = "PreHub01DualButtonOnePortalEntry01", completed = "PreHub01DualButtonOnePortalSuccessB01" },
	{ map = "sp_a1_intro5", start = "sp_a1_intro5Start01", completed = "PreHub01DualButtonOnePortalSuccessB01" },
	{ map = "sp_a1_intro6", start = "sp_a1_intro6Start01", completed = "sp_a1_intro6End01" },
	{ map = "sp_a1_intro7", prestart = "sp_a1_intro7Start01" },
	--{ map = "sp_incinerator_01", exitstarted = "sp_incinerator_01Elevator01" },
	{ map = "sp_laser_redirect_intro", start = "sp_laser_redirect_introStart01", completed = "sp_laser_redirect_introEnd01" },
	{ map = "sp_laser_stairs", start = "sp_laser_stairsStart01", completed = "sp_laser_stairsEnd01" },
	{ map = "sp_laser_dual_lasers", prestart = "sp_laser_dual_lasersStart01", completed = "sp_laser_dual_lasersEnd01" },
	{ map = "sp_laser_over_goo", start = "sp_laser_over_gooStart01", completed = "sp_laser_over_gooEnd01" },
	{ map = "sp_catapult_intro", completed = "sp_catapult_introEnd01" },
	{ map = "sp_trust_fling", prestart = "sp_trust_flingStart01", completed = "sp_trust_flingEnd01" },
	{ map = "sp_a2_pit_flings", prestart = "sp_a2_pit_flingsStart01", completed = "sp_a2_pit_flingsCubeSmuggleEnding01" },
	{ map = "sp_a2_fizzler_intro", start = "sp_a2_fizzler_introStart01" },
	{ map = "sp_catapult_fling_sphere_peek", completed = "sp_catapult_fling_sphere_peekEnd01" },
	{ map = "sp_a2_ricochet", prestart = "sp_a2_ricochetStart01", completed = "sp_a2_ricochetEnd01" },
	{ map = "sp_bridge_intro", completed = "sp_bridge_introEnd01" },
	{ map = "sp_bridge_the_gap", prestart = "sp_bridge_the_gapStart01", completed = "sp_bridge_the_gapEnd01" },
	{ map = "sp_turret_training_advanced", prestart = "sp_turret_training_advancedStart01" },
	{ map = "sp_laser_relays", prestart = "sp_laser_relaysStart01", completed = "sp_laser_relaysEnd01" },
	{ map = "sp_a2_turret_blocker", prestart = "sp_turret_blocker_introStart01", completed = "sp_turret_blocker_introEnd01" },
	{ map = "sp_laser_vs_turret_intro", prestart = "sp_laser_vs_turret_introStart01", completed = "sp_laser_vs_turret_introEnd01" },
	{ map = "sp_a2_pull_the_rug", prestart = "sp_a2_pull_the_rugStart01", completed = "sp_a2_pull_the_rugEnd01" },
	--RING AROUND THE TURRETS NO LONGER IN THE TRACK
	--{ map = "sp_ring_around_the_turrets", completed = "sp_ring_around_the_turretsEnd01" },
	{ map = "sp_column_blocker", completed = "sp_column_blockerEnd01" },
	{ map = "sp_a2_laser_chaining", prestart = "sp_a2_laser_chainingStart01", completed = "sp_a2_laser_chainingEnd01" },
	--Turret Tower no longer in track
	--{ map = "sp_turret_tower", prestart = "sp_turret_towerStart01", completed = "sp_turret_towerEnd01" },
	{ map = "sp_a2_triple_laser", start = "sp_a2_triple_laserStart01", completed = "sp_a2_triple_laserEnd01" },
	{ map = "sp_sabotage_jailbreak", prestart = "sp_sabotage_jailbreakStart01" },
	{ map = "sp_a3_speed_ramp", prestart = "-3150_01" },
	{ map = "sp_a4_finale3", prestart = "-4849_01" },
}

//Generic glados dialog functions.
//PuzzleStart fires automatically as the player moves out of the level transition area
function PuzzleStart()
    printldebug("===============In Puzzle Start " .. game.GetMap())

    local mpco
    for index, level in ipairs(GladosDialog) do
        mpco = MapNameConversion(level.map)

        if (level.map == game.GetMap() or mpco == game.GetMap()) and level.start ~= nil then
            print("===============PuzzleStart: playing scene " .. tostring(level.start))
            GladosPlayVcd(level.start)
        end
    end
end

//PuzzlePreStart fires just after the level load
function PuzzlePreStart()
    printldebug("===============In Puzzle PreStart")

    local mpco
    for index, level in ipairs(GladosDialog) do
        mpco = MapNameConversion(level.map)

        if (level.map == game.GetMap() or mpco == game.GetMap()) and level.prestart ~= nil then
            printldebug("===============PuzzlePreStart: playing scene " .. tostring(level.prestart))
            GladosPlayVcd(level.prestart)
        end
    end
end

didLeftElevatorChamber = false

function LeftElevatorChamber()
    if not didLeftElevatorChamber then
        didLeftElevatorChamber = true

        local mpco
        for index, level in ipairs(GladosDialog) do
            mpco = MapNameConversion(level.map)

            if (level.map == game.GetMap() or mpco == game.GetMap()) and level.leftelevatorchamber ~= nil then
                printldebug("===============LeftElevatorChamber: playing scene " .. tostring(level.leftelevatorchamber))
                GladosPlayVcd(level.leftelevatorchamber)
            end
        end
    end
end

//ExitStarted fires when the exit elevator doors close
function ExitStarted()
    printldebug("===============In Puzzle ExitStarted")

    for _, level in ipairs(GladosDialog) do
        local mpco = MapNameConversion(level.map)

        if (level.map == game.GetMap() or mpco == game.GetMap()) and level.exitstarted then
            printldebug("===============ExitStarted: playing scene " .. level.exitstarted)
            GladosPlayVcd(level.exitstarted)
        end
    end
end

//PuzzleCompleted fires when the glados exit speech is supposed to trigger. It isn't fired automatically from an instance.
//It needs to fire from a trigger in the map
function PuzzleCompleted()
    for index, level in ipairs(GladosDialog) do
        local mpco = MapNameConversion(level.map)
        if (level.map == game.GetMap() or mpco == game.GetMap()) and level.completed ~= nil then
            printldebug("===============PuzzleCompleted: playing scene " .. level.completed)
            GladosPlayVcd(level.completed)
        end
    end
end


//--------------------------------------------------------------------------------------------------------------
//Queue Functions
//	-This is the queue of scenes delayed by another scene
//--------------------------------------------------------------------------------------------------------------

Queue = {}

//Initialize the queue
function QueueInitialize()
	Queue = {}
end

//Add a scene to the queue
//Queue table structure:
//	item 						= index in SceneTable (ie: SceneTable[Queue[index].item])
//	added						= time added to queue
//	queueforcesecs	= (from SceneTable) force item to play after queueforcesecs seconds in queue
//	queuetimeout		= (from SceneTable) delete item if it sits in queue for queuetimeout seconds
//	queuepredelay		= (from SceneTable) wait queuepredelay seconds to fire the scene if it sat in the queue for any amount of time
function QueueAdd(arg)
    Queue[#Queue + 1] = { item = arg, added = CurTime() }

    if SceneTable[arg] then
        local last = Queue[#Queue]

        if SceneTable[arg].queueforcesecs then
            last.queueforcesecs = SceneTable[arg].queueforcesecs
        else
            last.queueforcesecs = 45.0
        end

        if SceneTable[arg].queuetimeout then
            last.queuetimeout = SceneTable[arg].queuetimeout
        end

        if SceneTable[arg].queuepredelay then
            last.queuepredelay = SceneTable[arg].queuepredelay
        end
    end
end

//Returns number of items in the queue
function QueueLen(char)
    char = char or nil
    local i = 0

    if char == nil then
        return #Queue
    else
        for index, scene in ipairs(Queue) do
            if SceneTable[scene.item] and SceneTable[scene.item].char == char then
                i = i + 1
            end
        end
        return i
    end
end

//Fetch the next scene in the queue
-- Get the next item from the queue
function QueueGetNext()
    local ret = nil
    local l = QueueLen()
    if l > 0 then
        ret = Queue[l].item
        table.remove(Queue, l)
    end
    return ret
end

-- Debug print the queue
function QueueDebug()
    printldebug("=================== items in queue -> " .. #Queue)
    for index, scene in ipairs(Queue) do
        if SceneTable[scene.item] then
            printldebug("========= queue item " .. index .. " (" .. scene.item .. "): character " .. SceneTable[scene.item].char)
        end
    end
end

-- Process the queue, removing timed-out items and returning any ready to force-fire
function QueueThink()
    if QueueLen() == 0 then
        return nil
    end

    local t = Time()

    -- Remove any timed-out items
    for index = #Queue, 1, -1 do
        local scene = Queue[index]
        if scene.queuetimeout ~= nil then
            if t - scene.added > scene.queuetimeout then
                table.remove(Queue, index)
            end
        end
    end

    -- Check for forced-fire items
    for index, scene in ipairs(Queue) do
        if scene.queueforcesecs ~= nil then
            if t - scene.added > scene.queueforcesecs then
                local ret = scene.item
                table.remove(Queue, index)
                return ret
            end
        end
    end

    return nil
end

//Debug testbed function
-- QueueTest function
function QueueTest()
    local a = {}

    -- Fill the table with random numbers
    for i = 0, 9 do
        table.insert(a, math.random(1, 100))
        print(">>>>>> " .. i .. " : " .. a[i + 1]) -- Lua tables are 1-indexed
    end

    -- Remove numbers less than 50
    for i = #a, 1, -1 do
        if a[i] < 50 then
            table.remove(a, i)
        end
    end

    -- Print the remaining elements
    for index, n in ipairs(a) do
        print(">>>>>> " .. index .. " : " .. n)
    end
end

-- Delete a single item from the queue
function QueueDeleteItem(item)
    if QueueLen() == 0 then
        return false
    end

    for index, scene in ipairs(Queue) do
        if scene.item == item then
            table.remove(Queue, index)
            return true
        end
    end

    return false
end

-- Check and fire a queued scene
function QueueCheck()
    if QueueLen() > 0 then
        print("===QUEUE LEN IS " .. QueueLen())
        local tmp = QueueGetNext()
        if tmp ~= nil then
            firedfromqueue = true
            GladosPlayVcd(tmp, true)
            return true
        end
    end

    return false
end


//--------------------------------------------------------------------------------------------------------------
//End of Queue Functions
//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------
//sp_sabotage_jailbreak specific functions 
//--------------------------------------------------------------------------------------------------------------

function jailbreak_alert(arg)
	jailbreakpos = arg
	printldebug("==========JAILBREAK ALERT " .. arg)
end

function jailbreak_whoah_speech()
	if jailbreakpos == 0 then
		GladosPlayVcd(303)
	else
		GladosPlayVcd(302)
	end
end


//--------------------------------------------------------------------------------------------------------------
//sp_sabotage_darkness specific functions 
//--------------------------------------------------------------------------------------------------------------


function PlayGhostStory()
	GladosPlayVcd(445)
end

function PlaySmellyHumansOne()
	GladosPlayVcd(446)
end

function PlaySmellyHumansTwo()
	GladosPlayVcd(447)
end
 
function PlaySmellyHumansThree()
	GladosPlayVcd(448)
end

function PlaySmellyHumansFour()
	GladosPlayVcd(449)
end


//--------------------------------------------------------------------------------------------------------------
//Glados Battle specific functions 
//--------------------------------------------------------------------------------------------------------------

-- Initialize variables
glados_gibbering = false
glados_gibbering_start = CurTime()
glados_gibbering_next = 0.00
glados_gibbering_times = {}

glados_gibbering_times[1] = 0.7
glados_gibbering_times[2] = 1.37
glados_gibbering_times[3] = 1.22
glados_gibbering_times[4] = 1.27
glados_gibbering_times[5] = 5.29
glados_gibbering_times[6] = 4.15
glados_gibbering_times[7] = 3.35

-- Example map-specific variable
if curMapName == "sp_a2_core" then
    sp_a2_core_xfer_left_annex = false
end

-- Start GLaDOS gibberish
function sp_sabotage_glados_start_gibberish()
    -- Gibberish is off for now
    -- glados_gibbering = true
    glados_gibbering_start = CurTime()
    glados_gibbering_next = 0.00
end

-- Stop GLaDOS gibberish
function sp_sabotage_glados_stop_gibberish()
    glados_gibbering = false
end

-- Play GLaDOS gibberish
function sp_sabotage_glados_gibberish()
    local i = math.random(1, 7) -- RandomInt equivalent in Lua
    if CurTime() - glados_gibbering_start > glados_gibbering_next then
        RunConsoleCommand("scene_playvcd", "npc/glados/sp_sabotage_glados_gibberish0" .. i)
        glados_gibbering_start = CurTime()
        -- glados_gibbering_next = math.Rand(3.5, 5.0) -- optional random
        glados_gibbering_next = glados_gibbering_times[i]
    end
end




// ==============================
// player starts vault trap
// ==============================
function VaultTrapStart()
	GladosPlayVcd(-50)
end

// ==============================
// player begins moving in relaxation vault
// ==============================
function VaultTrapStartMoving() 
	GladosPlayVcd(-53)
end

// ==============================
// turrets are on the ground and begin their scene
// ==============================
function TurretScene()
	GladosPlayVcd(-700)
end
 
// ==============================
// ==============================
function TurretDeathReactionDialog()
	GladosPlayVcd(-57)
	//gladosbattle_pre_05 // my turrets!
	//gladosbattle_pre_06 // oh, you were busy back there
	//gladosbattle_pre_17 // i suppose we could just sit here and glare ... but i have a better idea
end



// ==============================
// ==============================
function WheatleyBouncingDownTubeDialog()
	// play various "ouch.. oof... ow..." lines here
	// play glados dialog responding to wheatley falling.  "...sigh..."
end


// ==============================
// ==============================
function WheatleyLandsInChamberDialog()
	GladosPlayVcd(-61)
	printldebug("==========HELLO!!!!!!!!!!!!!!!!!!!!!")
	//wheatley - gladosbattle_pre01 // Hello!
	//gladosbattle_pre_09 // i hate you so much
end

// ==============================
// ==============================
function CoreDetectedDialog()
	//announcer - gladosbattle02 // warning: core corrupted
	//glados - gladosbattle_xfer04 // that's funny i don't feel corrupted. in fact i feel pretty good
	//announcer - gladosbattle03 // alternate core detected
	//wheatley pre05  // ah that's me they're talking about!
	//announcer - gladosbattle03 // to initiate a core transfer deposit core in receptacle
	//ent_fire "deploy_core_receptacle_relay" trigger // deploys the core receptacle
	//glados - gladosbattle_xfer05 // core transfer?
	//glados - gladosbattle_xfer06 // oh you are kidding me
	
end


// ==============================
// ==============================
function WheatleyCoreSocketed()

	StopWheatleyPluginNag()
	GladosPlayVcd(-71) // announcer - substitute core accepted.  core, are you willing to start the procedure?
	
end

// ==============================
//	called when the player reaches a catapult or enters the room to press stalemate button
// ==============================
function StalemateAssociateNotSoFast()
	StopWheatleyPluginNag()
	GladosPlayVcd(-84)
end


// ==============================
// ==============================
function CoreTransferInitiated()
	// start the core particle system
	nuke()
	EntFire("glados_shutdown_particles_relay", "trigger", 0, 0 )
	GladosPlayVcd(-88) //Stalemate Resolved. Core Transfer Initiated.
end

// ==============================
// ==============================
function WheatleyCoreTransferStart()
	sp_a2_core_xfer_left_annex = true
	//nuke()
	GladosPlayVcd(-4) // Here I go!
end

function sp_a2_core_leave_annex_nag()
	if not sp_a2_core_xfer_left_annex then
		GladosPlayVcd(-45)
	end
end

// ==============================
// ==============================
function PitHandsGrabGladosHead()
	GladosPlayVcd(-89) // Get your hands off me!
end

// ==============================
// ==============================
function PullGladosIntoPit()
	GladosPlayVcd(-90) // CHELL! STOP THIS! I AM YOUR MOTHER!
end

// ==============================
// ==============================
function CoreTransferCompleted()
	GladosPlayVcd(-9)  // Wow! Check ME out, Partner! .. Look how small you are!
end

// ==============================
// ==============================
function PlayerEnteredElevator()
	StopWheatleyElevatorNag()
	CorePlayerInElevator = 1 // this will prevent the elevator nag from being triggered by subsequent IO
	EntFire("@exit_elevator_music_relay","trigger", 0, 0 )
	GladosPlayVcd(-13) // I knew it was going to be cool being in charge..
	
	// delete many of the small_pos arms
	EntFire("small_pos1", "kill", 0, 0 )
	EntFire("small_pos3", "kill", 0, 0 )
	EntFire("small_pos4", "kill", 0, 0 )
	EntFire("small_pos7", "kill", 0, 0 )
	EntFire("small_pos9", "kill", 0, 0 )
	EntFire("small_pos10", "kill", 0, 0 )
end


// ==============================
// ==============================
function DialogDuringPotatosManufacture()
	GladosPlayVcd(-33)
end

// ==============================
// ==============================
function PotatosPresentation()
	GladosPlayVcd(-34)
end

// ==============================
// ==============================
function ElevatorMoronScene()
	GladosPlayVcd(-37)
end

// ==============================
// ==============================
function ElevatorConclusion()
	GladosPlayVcd(-44)
end


//--------------------------------------------------------------------------------------------------------------
//sp_sabotage_factory functions 
//--------------------------------------------------------------------------------------------------------------

function sabotage_factory_WatchTheLine()
	GladosPlayVcd(441)
end

function sabotage_factory_ReachedHackingSpot()
	GladosPlayVcd(442)
end

function sabotage_factory_PlayerReachedWheatley()
	WheatleyStopNag()
	GladosPlayVcd(443)
end

function sabotage_factory_PlayerReachedExitDoor()
	WheatleyStopNag()
	GladosPlayVcd(444)
end


//--------------------------------------------------------------------------------------------------------------
//sp_sabotage_factory - Science Fair functions 
//--------------------------------------------------------------------------------------------------------------
function ScienceFairGoingTheRightWay()
	GladosPlayVcd( -100 )
end

function ScienceFairBringDaughter()
	GladosPlayVcd( -101 )
end

function JustToReassureYou()
	GladosPlayVcd( -102 )
end

function DefinitelySureThisWay()
	GladosPlayVcd( -103 )
end


//--------------------------------------------------------------------------------------------------------------
//sp_catapult_fling_sphere_peek functions 
//--------------------------------------------------------------------------------------------------------------

function sp_catapult_fling_sphere_peek()
    if peekctr == 0 then
        GladosPlayVcd(335)
    elseif peekctr == 2 then
        GladosPlayVcd(362)
    elseif peekctr == 4 then
        GladosPlayVcd(363)
    end

    peekctr = peekctr + 1
end


//--------------------------------------------------------------------------------------------------------------
//New test functions 
//--------------------------------------------------------------------------------------------------------------
function GladosTest1(arg)
    -- Iterate backwards to safely remove items while looping
    for i = #arg, 1, -1 do
        local scene = arg[i]
        if scene.item then
            table.remove(arg, i)
        end
    end
end


//--------------------------------------------------------------------------------------------------------------
//Scenes List Functions START
//	-This is the list of currently playing scenes
//--------------------------------------------------------------------------------------------------------------

scene = {}
scene.__index = scene

-- Constructor
function scene.new(a, caller)
    local self = setmetatable({}, scene)

    self.index = a or 0
    self.owner = caller or nil
    self.currentCharacter = ""
    self.waitSceneStart = 0
    self.waiting = 0
    self.waitVcdCurrent = nil
    self.waitStartTime = CurTime()
    self.waitLength = CurTime()
    self.waitNext = nil
    self.waitExitingEarly = false
    self.waitExitingEarlyStartTime = CurTime()
    self.waitExitingEarlyThreshold = 0.0
    self.waitDelayingUntil = nil
    self.waitPreDelayed = false
    self.waitPreDelayedEntry = nil
    self.waitNoDingOff = false
    self.waitNoDingOn = false
    self.waitVcdTeam = -1
    self.waitFiredVcds = {}
    self.nagminsecs = 0
    self.nagmaxsecs = 0
    self.nags = {}
    self.isNag = false
    self.nagpool = {}
    self.naglastfetched = nil
    self.nagrandom = false
    self.nagrandomonrepeat = false
    self.nagtimeslistcompleted = 0
    self.nagrepeat = false
    self.naginchain = false

    return self
end

-- Methods
function scene:nagsClear()
    self.naglastfetched = nil
    self.nags = {}
end

function scene:nagpoolClear()
    self.nagpool = {}
end

function scene:addFiredVcd(team)
    table.insert(self.waitFiredVcds, team)
end

function scene:deleteFiredVcd(team)
    for idx, val in ipairs(self.waitFiredVcds) do
        if val == team then
            table.remove(self.waitFiredVcds, idx)
            break
        end
    end
end


-- Add a scene to the queue
function scenequeue_AddScene(arg, char)
    local delme = nil

    for idx, val in ipairs(scenequeue) do
        if SceneTable[idx].char == char then
            delme = idx
        end
        if idx == arg then
            print("[DEBUG] >>>>>>>>>>Scene " .. arg .. " is already in the queue")
            return nil
        end
    end

    if delme ~= nil then
        print("[DEBUG] >>>>>>>>>>DELETING SCENE " .. delme)
        scenequeue_DeleteScene(delme)
    end

    -- Add the new scene (assuming `scene` is a constructor function)
    scenequeue[arg] = scene.new(arg, this)
    scenequeue_Dump()
    return scenequeue[arg]
end

-- Delete a scene from the queue
function scenequeue_DeleteScene(arg)
    for idx, val in ipairs(scenequeue) do
        if idx == arg then
            print("[DEBUG] >>>>>>>>>>Scene " .. arg .. " deleted!")
            scenequeue[arg] = nil  -- Lua equivalent of 'delete'
            return true
        end
    end
    return nil
end

-- Dump the queue for debugging
function scenequeue_Dump()
    print("[DEBUG] >>>>>>>>>>Scene Dump at " .. CurTime())
    for idx, val in ipairs(scenequeue) do
        print("[DEBUG] >>>>>>>>>>Scene " .. idx .. " ADDED at " .. tostring(val.waitStartTime) .. " Type " .. type(val))
    end
end


//--------------------------------------------------------------------------------------------------------------
//Scene Queue Functions END
//--------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------
//Nag Table Functions START
//--------------------------------------------------------------------------------------------------------------

function nags_init(inst, scenetableentry)
    -- Clear existing nags
    inst.nagsClear()

    -- Set nag min/max seconds
    if SceneTable[scenetableentry].idleminsecs ~= nil then
        inst.nagminsecs = SceneTable[scenetableentry].idleminsecs

        if SceneTable[scenetableentry].idlemaxsecs ~= nil then
            inst.nagmaxsecs = SceneTable[scenetableentry].idlemaxsecs
        else
            inst.nagmaxsecs = inst.nagminsecs
        end
    end

    -- Set random/repeat flags
    if SceneTable[scenetableentry].idlerandomonrepeat ~= nil then
        inst.nagrandomonrepeat = true
    end
    if SceneTable[scenetableentry].idlerepeat ~= nil then
        inst.nagrepeat = true
    end
    if SceneTable[scenetableentry].idlerandom ~= nil then
        inst.nagrandom = true
    end

    local igroup = SceneTable[scenetableentry].idlegroup

    -- Iterate over all entries in SceneTable
    for idx, val in pairs(SceneTable) do
        if val.idlegroup == nil then continue end
        if val.idlegroup ~= igroup then continue end

        local rar = 101
        local mnum = 0
        if val.idlerarity ~= nil then
            rar = val.idlerarity
        end
        if val.idlemaxplays ~= nil then
            mnum = val.idlemaxplays
        end

        -- Skip VCDs that are part of a chain (not the first link)
        if val.idleunder ~= nil then continue end

        local oig = 0
        if val.idleorderingroup ~= nil then
            oig = val.idleorderingroup
        end

        table.insert(inst.nags, {
            SceneTableIndex = idx,
            rarity = rar,
            maxplays = mnum,
            totplays = 0,
            orderingroup = oig
        })
    end

    -- Sort the nags
    table.sort(inst.nags, function(a, b)
        return nag_array_compare(a, b) < 0
    end)

    -- Initialize nagging state
    inst.isNag = true
    inst.nagtimeslistcompleted = 0

    -- Create the nag pool
    nags_createpool(inst)
end

function nags_createpool(inst)
    -- Clear the current nag pool
    inst.nagpoolClear()

    local tempa = {}

    -- Build a temporary pool of eligible nags
    for _, val in ipairs(inst.nags) do
        local takeit = false

        -- Only proceed if maxplays not reached
        if not (val.maxplays > 0 and val.totplays >= val.maxplays) then
            -- Roll for rarity
            if math.random(1, 100) < val.rarity then
                takeit = true
            end

            if takeit then
                table.insert(tempa, val)
            end
        end
    end

    -- If pool is empty, exit
    if #tempa == 0 then return end

    -- Randomize the pool if necessary
    if inst.nagrandom or (inst.nagrandomonrepeat and inst.nagtimeslistcompleted > 0) then
        -- Ensure first entry is not the same as last fetched
        if #tempa > 1 and inst.naglastfetched ~= nil then
            while true do
                local r = math.random(1, #tempa)
                if tempa[r].SceneTableIndex ~= inst.naglastfetched then
                    table.insert(inst.nagpool, tempa[r])
                    table.remove(tempa, r)
                    break
                end
            end
        end

        -- Add the rest of the pool randomly
        while #tempa > 0 do
            local r = math.random(1, #tempa)
            table.insert(inst.nagpool, tempa[r])
            table.remove(tempa, r)
        end
    else
        -- Simply append in order
        for _, val in ipairs(tempa) do
            table.insert(inst.nagpool, val)
        end
    end
end


function nags_nagpooldump(inst)
    for idx, val in ipairs(inst.nagpool) do
        print("[DEBUG] *********NAG " .. idx .. " : " .. val.SceneTableIndex)
    end
end

function nags_fetch(inst)
    -- Check if the nag pool is empty
    if #inst.nagpool == 0 then
        if inst.nagrepeat then
            inst.nagtimeslistcompleted = inst.nagtimeslistcompleted + 1
            nags_createpool(inst)
            if #inst.nagpool == 0 then
                return nil
            end
        else
            return nil
        end
    end

    -- Fetch the first item from the pool
    local ret = inst.nagpool[1].SceneTableIndex  -- Lua tables are 1-indexed

    -- Increment totplays in the main nags list
    for idx, val in ipairs(inst.nags) do
        if val.SceneTableIndex == ret then
            val.totplays = val.totplays + 1
            break
        end
    end

    -- Remove the first item from the pool
    table.remove(inst.nagpool, 1)

    -- Store the last fetched index
    inst.naglastfetched = ret

    return ret
end

function GladosStopNag(arg)
    arg = 0
	nag_stop("glados",arg)
end

function WheatleyStopNag(arg)
    arg = 0
	nag_stop("wheatley",arg)
end

function Core01StopNag(arg)
    arg = 0
	nag_stop("core01",arg)
end

function Core02StopNag(arg)
    arg = 0
	nag_stop("core02",arg)
end

function Core03StopNag(arg)
    arg = 0
	nag_stop("core03",arg)
end


function nag_stop(char, stoptype)
	local idx, val
	local todel = null
	for idx, val in ipairs(scenequeue) do
		if val.isNag and val.currentCharacter == char  then
			todel=idx
			break
		end
	end
	if todel ~= nil then
		scenequeue_DeleteScene(todel)	
	end
end

function nag_array_compare(a, b)
    if a.orderingroup > b.orderingroup then
        return 1
    elseif a.orderingroup < b.orderingroup then
        return -1
    end
    return 0
end


//--------------------------------------------------------------------------------------------------------------
//Nag Table Functions END
//--------------------------------------------------------------------------------------------------------------


function TrustFlingCatapultTurretNoticesPlayer()
	GladosPlayVcd(439, nil, "catapulted_turret")
end

//--------------------------------------------------------------------------------------------------------------
//Elevator Stoppage in bridge over goo
//--------------------------------------------------------------------------------------------------------------

function sp_a2_laser_over_goo_elevator_stoppage()
	GladosPlayVcd(465)
	// @trigger_this_to_stop_elevator
	// @trigger_this_to_start_elevator
end


//--------------------------------------------------------------------------------------------------------------
//sp_a1_intro7 functions
//--------------------------------------------------------------------------------------------------------------
if curMapName=="sp_a1_intro7" then
	local sp_a1_intro7_popped = false
	local sp_a1_intro7_camethrough = false
	local sp_a1_intro7_pickedup = false
	local sp_a1_intro7_pickedupcount = 0
	local sp_a1_intro7_pluggedin = false
	local sp_a1_intro7_turnedaway = false
	local sp_a1_intro7_sayingnotdead = false
	local sp_a1_intro7_saidnotdead = false
end

function sp_a1_intro7_HeyUpHere()
	GladosPlayVcd(466)
end

function sp_a1_intro7_YouFoundIt()
	EntFire("spherebot_train_1_chassis_1","MoveToPathNode","spherebot_train_1_path_11",8.5)
	GladosPlayVcd(467)
end

function sp_a1_intro7_PopPortal()
	if not sp_a1_intro7_popped then
		GladosPlayVcd(469)
	end
end


function sp_a1_intro7_PopPortalNag()
	if not sp_a1_intro7_popped then
		GladosPlayVcd(468)
	end
end

function sp_a1_intro7_ComeThroughNag()
	if not sp_a1_intro7_camethrough then
		GladosPlayVcd(470)
	end
end


function sp_a1_intro7_PoppedAPortal()
	EntFire("portal_detector","Disable","",0.0)
	EntFire("@glados","runscriptcode","sp_a1_intro7_ComeThroughNag()",4.0)
	WheatleyStopNag()
	sp_a1_intro7_popped = true
end

function sp_a1_intro7_JumpToOtherSide()
	WheatleyStopNag()
	sp_a1_intro7_camethrough = true
end

function sp_a1_intro7_ManagementRail()
	//WheatleyStopNag()
	GladosPlayVcd(471)
end

function sp_a1_intro7_OnThree()
	GladosPlayVcd(472)
end

function sp_a1_intro7_Impact()
	GladosPlayVcd(473)
end


function sp_a1_intro7_NotDeadStart()
	sp_a1_intro7_sayingnotdead = true
end

function sp_a1_intro7_NotDeadEnd()
	sp_a1_intro7_sayingnotdead = false
	sp_a1_intro7_saidnotdead = true
	if sp_a1_intro7_pickedup then
		nuke()
		GladosPlayVcd(572)
	end
end


function sp_a1_intro7_PickMeUpNag()
	if not sp_a1_intro7_pickedup then
		GladosPlayVcd(474)
	end
end

function sp_a1_intro7_PickUp()
    sp_a1_intro7_pickedup = true

    if sp_a1_intro7_pickedupcount == 0 then
        sp_a1_intro7_pickedupcount = sp_a1_intro7_pickedupcount + 1

        -- Before the "I'm not dead!" line has started playing
        if not sp_a1_intro7_sayingnotdead and not sp_a1_intro7_saidnotdead then
            nuke()
            GladosPlayVcd(571)
        else
            -- The "I'm not dead!" line finished playing before the pickup happened
            if not (not sp_a1_intro7_saidnotdead and sp_a1_intro7_sayingnotdead) then
                WheatleyStopNag()
                GladosPlayVcd(475)
            end
        end

    elseif sp_a1_intro7_pickedupcount == 1 then
        sp_a1_intro7_pickedupcount = sp_a1_intro7_pickedupcount + 1
        nuke()
        GladosPlayVcd(577)
    end
end

function sp_a1_intro7_PlugMeInNag()
	if not sp_a1_intro7_pluggedin then
		GladosPlayVcd(476)
	end
end

function sp_a1_intro7_NoWatching()
	sp_a1_intro7_pluggedin = true
	WheatleyStopNag()
	GladosPlayVcd(477)
end

function sp_a1_intro7_NoWatchingNag()
	if not sp_a1_intro7_turnedaway then
		GladosPlayVcd(481)
	end
end

function sp_a1_intro7_TurnAroundNow()
	sp_a1_intro7_turnedaway = true
	WheatleyStopNag()
	GladosPlayVcd(478)
end

function sp_a1_intro7_BamSecretPanel()
	sp_a1_intro7_turnedaway = true
	WheatleyStopNag()
	GladosPlayVcd(479)
end

function sp_a1_intro7_GloriousFreedom()
	GladosPlayVcd(480)
end

function sp_a1_intro7_DontLeaveMeNag()
end



//--------------------------------------------------------------------------------------------------------------
//sp_a1_wakeup functions
//--------------------------------------------------------------------------------------------------------------

if curMapName=="sp_a1_wakeup" then
	local sp_a1_wakeup_gantryexpositionover = false
	local sp_a1_wakeup_gantryexpositioncounter = 0
	local sp_a1_wakeup_humanexpositionover = false
	local sp_a1_wakeup_In_Breaker_Room = false
	local sp_a1_wakeup_Looked_Down = false
end

function sp_a1_wakeup_start_map()
	GladosPlayVcd(482)
end

function sp_a1_wakeup_gantry_exposition_end()
	sp_a1_wakeup_gantryexpositionover = true
end

function sp_a1_wakeup_inside_observation()
    if sp_a1_wakeup_gantryexpositionover then
        sp_a1_wakeup_gantryexpositionover = false

        if sp_a1_wakeup_gantryexpositioncounter == 0 then
            sp_a1_wakeup_gantryexpositioncounter = sp_a1_wakeup_gantryexpositioncounter + 1
            GladosPlayVcd(483)
        elseif sp_a1_wakeup_gantryexpositioncounter == 1 then
            sp_a1_wakeup_gantryexpositioncounter = sp_a1_wakeup_gantryexpositioncounter + 1
            GladosPlayVcd(484)
        elseif sp_a1_wakeup_gantryexpositioncounter == 2 then
            sp_a1_wakeup_gantryexpositioncounter = sp_a1_wakeup_gantryexpositioncounter + 1
            GladosPlayVcd(485)
        elseif sp_a1_wakeup_gantryexpositioncounter == 3 then
            sp_a1_wakeup_gantryexpositioncounter = sp_a1_wakeup_gantryexpositioncounter + 1
            GladosPlayVcd(486)
        end
    end
end

function sp_a1_wakeup_gantry_door_open()    
	GladosPlayVcd(487)
end

function sp_a1_wakeup_there_she_is()
		GladosPlayVcd(488)
end

function sp_a1_wakeup_human_exposition_end()
	sp_a1_wakeup_gantryexpositionend = true
end

function sp_a1_wakeup_down_the_stairs()
		GladosPlayVcd(489)
end

function sp_a1_wakeup_JumpNags()
	GladosPlayVcd(581)
end

function sp_a1_wakeup_Falling()
	nuke()
	GladosPlayVcd(579)
end

function sp_a1_wakeup_Landed()
	GladosPlayVcd(580)
end

function sp_a1_wakeup_come_through_here()
	if sp_a1_wakeup_Looked_Down then
		GladosPlayVcd(586)
	end
end

function sp_a1_wakeup_Do_Not_Look_Down()
		GladosPlayVcd(491)
end

function sp_a1_wakeup_Do_Not_Look_Down_Over()
	sp_a1_wakeup_Looked_Down = true
	EntFire("@ComeThroughHereTrigger","enable","",0.2)
end


function sp_a1_wakeup_This_Is_Breaker_Room()
		GladosPlayVcd(492)
end

function sp_a1_wakeup_Lets_Go_In()
		if not sp_a1_wakeup_In_Breaker_Room then
			GladosPlayVcd(585)
        end
end

function sp_a1_wakeup_Do_Not_Touch()
		sp_a1_wakeup_In_Breaker_Room = true
		GladosPlayVcd(493)
end

function sp_a1_wakeup_Lights_On()
		GladosPlayVcd(494)
end

function sp_a1_wakeup_Oops()
	GladosPlayVcd(542)
end

//--------------------------------------------------------------------------------------------------------------
//Wheatley Elevator Scene (currently after sp_a2_column_blocker)
//--------------------------------------------------------------------------------------------------------------


function Wheatley_Elevator_Scene_Start()
		GladosPlayVcd(495)
end

function Wheatley_Elevator_Scene_Ow()
		GladosPlayVcd(496)
end

//--------------------------------------------------------------------------------------------------------------
//Jailbreak - sp_a2_bts1 & bts2
//--------------------------------------------------------------------------------------------------------------

if curMapName == "sp_a2_bts1" then
	sp_a2_bts1_FakeEntered = false
end



function JailbreakGladosSomethingWrong()
	GladosPlayVcd(301)
end

function JailbreakWheatleyHeyLady()
	GladosPlayVcd(497)
end

function JailbreakICanHearYou()
	nuke()
	EntFire( "@sphere", "SetIdleSequence", "sphere_damaged_glance_concerned", 0 )
	GladosPlayVcd(498)
end

function JailbreakWheatleyCloseChamber()
	WheatleyStopNag()	
	GladosPlayVcd(500)
end

function WheatleyKeepMoving()
	//WheatleyStopNag()	
	//GladosPlayVcd(501)
end

function WheatleyGoGoGoNag()
	GladosPlayVcd(502)
end

function JailbreakLastTestIntro()
	WheatleyStopNag()	
	GladosPlayVcd(503)
end

function JailbreakLastChamberMain()
	WheatleyStopNag()	
	GladosPlayVcd(504)
end

function JailbreakLastTestDeer()
	sp_a2_bts1_FakeEntered = true
	WheatleyStopNag()	
	GladosPlayVcd(505)
end

function JailBreakHowStupid()
	if not sp_a2_bts1_FakeEntered then
		WheatleyStopNag()	
		GladosPlayVcd(506)
    end
end

function JailbreakBridgeDisappear()
	WheatleyStopNag()	
	GladosPlayVcd(507)
end

function JailbreakLookOutTurrets()
	WheatleyStopNag()	
	GladosPlayVcd(508)
end

function JailBreak2Trapped()
	WheatleyStopNag()	
	GladosPlayVcd(573)
end

function JailBreak2Gunfire()
	GladosPlayVcd(574)
end

function bts2_wheatley_comeon_prompt()
	GladosPlayVcd(587)
end

function JailBreak2AlmostOut()
	GladosPlayVcd(575)
end

function JailBreak2BringingDown()
	GladosPlayVcd(576)
end

function JailbreakHurryHurry()
	WheatleyStopNag()	
	GladosPlayVcd(509)
end

function JailbreakGetInTheLift()
	WheatleyStopNag()	
	GladosPlayVcd(510)
end

function jailbreak_player_in_exit_elevator()
	WheatleyStopNag()	
	GladosPlayVcd(511)
end

function Jailbreak2ThisWay()
	WheatleyStopNag()	
	GladosPlayVcd(512)
end

function JailbreakGoGo()
	WheatleyStopNag()	
	GladosPlayVcd(513)
end

function JailbreakComeOnComeOn()
	WheatleyStopNag()	
	GladosPlayVcd(514)
end
--[[

//--------------------------------------------------------------------------------------------------------------
//Turret Factory -- sp_a2_bts4
//--------------------------------------------------------------------------------------------------------------

if (curMapName=="sp_a2_bts4")
{
	sp_a2_bts4_StillThinkingNagStage <- 0
	sp_a2_bts4_StillThinkingNagOK <- false
	sp_a2_bts4_StillThinkingNagIdx <- 0
	sp_a2_bts4_StillThinkingNagTime <- 0
	sp_a2_bts4_MentionedSwap <- false
	sp_a2_bts4_At_Window <- false
	sp_a2_bts4_At_Big_Potato <- false
	sp_a2_bts4_At_Volcano <- false
	sp_a2_bts4_Intro_Talking <- false
	sp_a2_bts4_Science_Fair_Busy <- false
	sp_a2_bts4_Did_Big_Potato <- false
	sp_a2_bts4_Did_Volcano <- 0
	
}	


function FactoryWheatleyHey()
{
	GladosPlayVcd(515)
}

function FactoryFollowMe()
{
	GladosPlayVcd(516)
}

function FactoryAlmostThere()
{
	GladosPlayVcd(518)
}


function FactoryTahDah()
{
	GladosPlayVcd(517)
}

function FactoryScannerIntro()
{
	sp_a2_bts4_At_Window = true
	if (!sp_a2_bts4_Intro_Talking)
	{
		GladosPlayVcd(519)
	}
}

function FactoryScannerSpeech()
{
	GladosPlayVcd(519)
}

function FactoryCheckAtWindowEnd()
{
	sp_a2_bts4_Intro_Talking = false
	if (sp_a2_bts4_At_Window)
	{
		FactoryScannerSpeech()
	}
}

function FactoryCheckAtWindowStart()
{
	sp_a2_bts4_Intro_Talking = true
	if (sp_a2_bts4_At_Window)
	{
		FactoryScannerSpeech()
	}
}


function FactoryControlDoorHackIntro()
{
	GladosPlayVcd(520)
}

function FactoryControlRoomHackSuccess()
{
	WheatleyStopNag()	
	GladosPlayVcd(521)
}

function FactoryFirstTurretTaken()
{
	WheatleyStopNag()	
	GladosPlayVcd(522)
}

function FactoryFirstTurretPulled()
{
	//WheatleyStopNag()	
	//GladosPlayVcd(522)
}


function FactoryEnableThinkingNag()
{
	printldebug("%%%%%%%%%%%%%%%%ENABLE STILL THINKING NAG")
	sp_a2_bts4_StillThinkingNagOK = true
}

function FactoryDisableThinkingNag()
{
	printldebug("%%%%%%%%%%%%%%%%DISABLE STILL THINKING NAG")
	sp_a2_bts4_StillThinkingNagOK = false
}

function FactoryStillThinkingNag()
{
	printldebug("%%%%%%%%%%%%%%%%STILL THINKING NAG")
	switch (sp_a2_bts4_StillThinkingNagStage)
	{
		case 0:
			if (!sp_a2_bts4_StillThinkingNagOK)
			{
				return
			}
			if (!(characterCurscene("wheatley")==null))
			{
				sp_a2_bts4_StillThinkingNagTime = Time()
				return
			}	
			if (Time()-sp_a2_bts4_StillThinkingNagTime > 5 && RandomInt(1,100) > 50)
			{
				sp_a2_bts4_StillThinkingNagIdx+=1
				sp_a2_bts4_StillThinkingNagTime=Time()
				switch (sp_a2_bts4_StillThinkingNagIdx)
				{
					case 1:
						GladosPlayVcd(523)
						break
					case 2:
						GladosPlayVcd(524)
						break
					case 3:
						GladosPlayVcd(525)
						break
					case 4:
						GladosPlayVcd(526)
						break
					case 5:
						GladosPlayVcd(527)
						break
					case 6:
						GladosPlayVcd(528)
						break
					case 7:
						sp_a2_bts4_MentionedSwap = true
						GladosPlayVcd(529)
						break
					case 8:
						sp_a2_bts4_MentionedSwap = true
						GladosPlayVcd(530)
						break
					default:
						sp_a2_bts4_MentionedSwap = true
						GladosPlayVcd(531)
						break
				}
			}
			break
		case 1:
	}
}	


function FactoryWhereAreYouGoing()
{
	if (!sp_a2_bts4_MentionedSwap)
	{
		GladosPlayVcd(532)
	}
}

function FactoryWhereAreYouGoingTwo()
{
	if (!sp_a2_bts4_MentionedSwap)
	{
		GladosPlayVcd(533)
	}	
}


function FactoryBroughtBackDefectiveTurret()
{
	printldebug("$$$$$$$$$$$$$CRAP TURRET TRIGGER")
	sp_a2_bts4_StillThinkingNagStage = 2
	if (sp_a2_bts4_MentionedSwap)
	{
		GladosPlayVcd(535)
	}
	else
	{
		GladosPlayVcd(534)
	}
}

function FactoryWheatleyShoutout()
{
	if (!sp_a2_bts4_MentionedSwap)
	{
		GladosPlayVcd(541)
	}
}

function FactoryEnterScannerRoomWithTurret()
{
	if (!sp_a2_bts4_MentionedSwap)
	{
		GladosPlayVcd(540)
	}
}

function FactorySuccess()
{
	sp_a2_bts4_StillThinkingNagStage = 2
	if (sp_a2_bts4_MentionedSwap)
	{
		GladosPlayVcd(539)
	}
	else
	{
		GladosPlayVcd(538)
	}
}


function ScienceFairBusy()
{
	sp_a2_bts4_Science_Fair_Busy = true
}

function ScienceFairNotBusy()
{
	sp_a2_bts4_Science_Fair_Busy = false
	if (sp_a2_bts4_At_Volcano)
	{
		PlayerNearScienceFairVolcano()
		return
	}
	if (sp_a2_bts4_At_Big_Potato)
	{
		PlayerLookingAtScienceFairPotato()
		return
	}
}


function PlayerNearScienceFairVolcano()
{
	sp_a2_bts4_At_Volcano = true
	if (!sp_a2_bts4_Science_Fair_Busy)
	{
		switch (sp_a2_bts4_Did_Volcano)
		{
			case 0:
				sp_a2_bts4_Did_Volcano = 1
				GladosPlayVcd(583)
				break
			case 1:
				sp_a2_bts4_Did_Volcano = 2
				GladosPlayVcd(584)
				break
		}		
	}	
}	

function PlayerLeavingScienceFairVolcano()
{
	sp_a2_bts4_At_Volcano = false
}


function PlayerLookingAtScienceFairPotato() // fires once player looks at potato plant
{
	sp_a2_bts4_At_Big_Potato = true
	if (!sp_a2_bts4_Science_Fair_Busy)
	{
		if (!sp_a2_bts4_Did_Big_Potato)
		{
			sp_a2_bts4_Did_Big_Potato = true
			GladosPlayVcd(582)
		}	
	}	
}


function PlayerNotLookingAtScienceFairPotato() // fires if player looks away from plant after looking at it
{
		sp_a2_bts4_At_Big_Potato = false
}


//--------------------------------------------------------------------------------------------------------------
// BTS4 conveyor turret functions
//--------------------------------------------------------------------------------------------------------------

// ========================================================
// Called when the player gets near the turret for the first time
// ========================================================

if (curMapName=="sp_a2_bts4")
{
	sp_a2_bts4_redemption_turret_held <- false
	sp_a2_bts4_redemption_turret_babble_index <- 0
	sp_a2_bts4_redemption_turret_babbling <- false
}	


function SabotageFactoryRecycledTurretNoticesPlayer()
{
	GladosPlayVcd(439, null, "conveyor_turret_body")
}


// ========================================================
// SP_A2_BTS4 ACHIEVEMENT - ACH.SAVE_REDEMPTION_TURRET
// ========================================================
function bts4_redemption_line_turret_achievement()
{	
	// award achievement after turret is done speaking
	EntFire("achievement_redemption_line", "fireevent", 0, 0 )
}

// ========================================================
// Called every time the turret is picked up
// ========================================================
function bts4_redemption_line_turret_pickup()
{
	sp_a2_bts4_redemption_turret_held = true
	if (!sp_a2_bts4_redemption_turret_babbling)
	{
		GladosPlayVcd(614, null, "conveyor_turret_body")
	}	
}

// ========================================================
// Called every time the turret is dropped
// NOTE: when turret gets fizzled it is also dropped
// so this function will get called
// ========================================================
function bts4_redemption_line_turret_drop()
{
	sp_a2_bts4_redemption_turret_held = false
}

function bts4_redemption_line_turret_babble_start()
{
	sp_a2_bts4_redemption_turret_babbling = true
}

function bts4_redemption_line_turret_babble_end()
{
	local dly = RandomInt(2,5)
	sp_a2_bts4_redemption_turret_babbling = false
	if (sp_a2_bts4_redemption_turret_held)
	{
		EntFire("@glados","runscriptcode","bts4_redemption_line_turret_babble()",dly)
	}
}


function bts4_redemption_line_turret_babble()
{
	if (!sp_a2_bts4_redemption_turret_babbling)
	{
		if (sp_a2_bts4_redemption_turret_held)
		{
			if (sp_a2_bts4_redemption_turret_babble_index < 8)
			{
				sp_a2_bts4_redemption_turret_babble_index+=1
				GladosPlayVcd(614+sp_a2_bts4_redemption_turret_babble_index, null, "conveyor_turret_body")
			}	
		}
	}	
}


// ========================================================
// Called if turret is not saved and goes through conveyor exit
// ========================================================
function bts4_redemption_line_turret_not_saved()
{
	GladosCharacterStopScene("conveyor_turret_body")
	GladosPlayVcd(613, null, "conveyor_turret_body")
}

// ========================================================
// Called if player and turret are approaching the fizzler
// NOTE: if the player leaves and comes back this could be triggered
// again!
// ========================================================
function bts4_redemption_line_fizzler_approach()
{
	
}

// ========================================================
// Called if turret gets fizzled
// ========================================================
function bts4_redemption_line_turret_fizzled()	
{
	GladosCharacterStopScene("conveyor_turret_body")
	GladosPlayVcd(613, null, "conveyor_turret_body")
}

// ========================================================
// Called when player gets into dummy shoot area
// ========================================================
function bts4_redemption_line_turret_safe()
{
	
}



//--------------------------------------------------------------------------------------------------------------
//Turret Factory -- sp_a2_intro - incinerator
//--------------------------------------------------------------------------------------------------------------

function sp_a2_intro_SecondSpeech()
{
	if (characterCurscene("glados")==null)
	{
		GladosPlayVcd(206)
	}
	else
	{
		GladosPlayVcd(543)
	}
}

function sp_a2_intro_ClearArms()
{
	if (characterCurscene("glados")==null)
	{
		GladosPlayVcd(208)
	}
	else
	{
		GladosPlayVcd(544)
	}
}



]]
//--------------------------------------------------------------------------------------------------------------
//sp_a1_intro1
//--------------------------------------------------------------------------------------------------------------

if curMapName=="sp_a1_intro1" then
	sp_a1_intro1_fizzler_triggered = false
	sp_a1_intro1_fizzler_said = false
	sp_a1_intro1_fizzler_passed = false
end

function sp_a1_intro1_fizzler_intro()
	sp_a1_intro1_fizzler_triggered = true
	if characterCurscene("glados") == nil then
		sp_a1_intro1_fizzler_said = true
		GladosPlayVcd(553)
    end
end

function sp_a1_intro1_fizzler_passed()
	if not sp_a1_intro1_fizzler_said then
		sp_a1_intro1_fizzler_passed = true
		if characterCurscene("glados") == nil then
			sp_a1_intro1_fizzler_said = true
			GladosPlayVcd(630)
        end
    end
end

function sp_a1_intro1_fizzler_test()
	if sp_a1_intro1_fizzler_triggered and not sp_a1_intro1_fizzler_said then
		sp_a1_intro1_fizzler_said = true
		if sp_a1_intro1_fizzler_passed then
			GladosPlayVcd(630)
		else
			GladosPlayVcd(553)
        end
	end
end

//--------------------------------------------------------------------------------------------------------------
//sp_a1_intro3
//--------------------------------------------------------------------------------------------------------------

//Triggers when you drop into the "Mind the Gap" puzzle
function sp_a1_intro3_turret_live_fire()
	GladosPlayVcd(623)
end


//--------------------------------------------------------------------------------------------------------------
//sp_a1_intro6
//--------------------------------------------------------------------------------------------------------------

function sp_a1_intro6_PuzzleOneCompleted()
	printldebug("Insert puzzle 1 completed dialog here.")
end



//--------------------------------------------------------------------------------------------------------------
//sp_a2_fizzler_training
//--------------------------------------------------------------------------------------------------------------
function sp_a2_fizzler_training_Have_To_Go()
	GladosPlayVcd(546)
end

//--------------------------------------------------------------------------------------------------------------
//sp_a4_turret_tbeam functions
//--------------------------------------------------------------------------------------------------------------

function Finale02_turret_tbeam_abort1()
	GladosPlayVcd(556)
end

function Finale02_turret_tbeam_2()
	GladosPlayVcd(557)
end

function Finale02_turret_tbeam_abort2()
	GladosPlayVcd(558)
end

function Finale02_turret_tbeam_3()
	GladosPlayVcd(559)
end

function Finale02_turret_tbeam_abort3()
	GladosPlayVcd(560)
end

//stub function from co-op
function BotDeath(arg,arg2)
end

//sp_a1_intro6_first half of chamber
function MidpointPuzzleCompleted()
	GladosPlayVcd(626)
end



//--------------------------------------------------------------------------------------------------------------
// Control Potatos light
//--------------------------------------------------------------------------------------------------------------

function PotatosTurnOff()
	GetPlayer().TurnOffPotatos();
end

function PotatosTurnOn()
	GetPlayer().TurnOnPotatos();
end